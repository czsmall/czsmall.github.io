[{"title":"测试文章","path":"/2023/09/14/测试页/","content":"在心率管家默默无闻地上线了一年多之后，现在终于打算来好好聊聊关于手机摄像头测量心率的那些事。本文参考了很多前辈的文章，将在文末列出。 后面是正文部分，在主页看不到。 h1 &#x2F;bibi&#x2F;poster: topic: #标题上方的小字 # 可选 headline: 测试文章页 caption: 下方的小标题 # color: 标题颜色 # 可选，默认为跟随主题的动态颜色 # white,red…tags: [测试] #标签categories: #分类相关文章推荐要实现相关文章推荐功能，您需要安装插件： npm i hexo-related-popular-posts然后在主题配置文件中开启： blog&#x2F;_config.stellar.ymlarticle: npm i hexo-related-popular-posts related_posts: enable: true title: 您可能感兴趣的文章Copy开启后会在每篇文章的下方推荐相同类型的文章。 参考资料填写引用文章的标题和链接： references: - title: ‘心跳之旅—💗—iOS用手机摄像头检测心率(PPG)’ url: https://punmy.cn/2016/07/28/15231176397746.html - title: ‘PPG光电容积脉搏波描记法技术概况’ url: https://www.jianshu.com/p/695c131abfa5 …[https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimg.nga.178.com%2Fattachments%2Fmon_202011%2F28%2F7nQ5-bx27XlZ5yT3cS1h8-tz.png&refer=http%3A%2F%2Fimg.nga.178.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=auto?sec=1697445446&t=cb5250208a77c702c701da03ced37ec4] [download:bool/string] Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start cover: &#x2F;assets&#x2F;xaoxuu&#x2F;blog&#x2F;&#x32;&#x30;&#50;&#x30;&#45;&#48;&#57;&#50;&#55;&#x61;&#64;&#x31;&#x78;&#46;&#115;&#x76;&#103; # 必选poster: # 海报（可选，全图封面卡片） topic: 标题上方的小字 # 可选 headline: 大标题 # 必选 caption: 标题下方的小字 # 可选 color: 标题颜色 # 可选，默认为跟随主题的动态颜色 # white,red… –topic 时大标题位于上方caption 时大标题位于下方 [描述] [download:bool/string] f 支持多彩标记，包括：默认 红 橙 黄 绿 青 蓝 紫 浅 深 警告 错误 一共 12 种颜色。mark 行内文本标记 支持多彩标记，包括： 默认 红 橙 黄 绿 青 蓝 紫 浅 深 警告 错误 一共 12 种颜色。 tag 标签 Stellar Hexo GitHub Gitea image 图片标签 [description] [download:true] [width:px] [padding:px] [bg:hex] src: 图片地址description: 图片描述download: href # 下载地址，设置此值后鼠标放在图片上会显示下载地址，如果下载地址为图片地址，可以设置为 truewidth: 200px # 图片宽度padding: 16px # 图片四周填充宽度bg: ‘#ffffff’ # 图片区域背景颜色，16进制 来自印度的 Rohit Vohra 使用 iPhone 12 Pro Max 拍摄。 没有底色的图片，可以填充 bg:var(–card) 动态颜色，能够适配暗黑模式： 适合居中且醒目的引用：Stellar 是最好用的主题支持自定义引号：热门话题 此外，加上 el:h2&#x2F;h3&#x2F;h4&#x2F;h5&#x2F;h6 可以作为标题使用 poetry 诗词 游山西村陆游莫笑农家腊酒浑，丰年留客足鸡豚。山重水复疑无路，柳暗花明又一村。箫鼓追随春社近，衣冠简朴古风存。从今若许闲乘月，拄杖无时夜叩门。诗词节选 title: 标题（可选）content: 内容color: red&#x2F;orange&#x2F;yellow&#x2F;green&#x2F;cyan&#x2F;blue&#x2F;purple&#x2F;light&#x2F;dark&#x2F;warning&#x2F;error 具有标题的备注块直接写备注内容，默认是和代码块一样的样式，第一个空格前面的是标题，后面的是正文，如果标题中需要显示空格，请使用 &nbsp; 代替。 这&nbsp;是/可用空格代替标题标题这是正文 哈哈。 彩色备注块 一共支持12种颜色，可以满足几乎所有的需求了。color 可设置 red、orange、yellow、green、cyan、blue、purple、light、dark、warning、error 几种取值。 一共支持12种颜色，可以满足几乎所有的需求了。color 可设置 red、orange、yellow、green、cyan、blue、purple、light、dark、warning、error 几种取值。 link 链接卡片 #% link href [title] [icon:src] [desc:true&#x2F;false] %# 不带摘要的样式： https://xaoxuu.com/blog/20221029/https://xaoxuu.com/blog/20221029/ 带摘要的样式： https://xaoxuu.com/blog/20221029/https://xaoxuu.com/blog/20221029/ href: 链接title: 可选，手动设置标题（为空时会自动抓取页面标题）icon: 可选，手动设置图标（为空时会自动抓取页面图标）desc: 可选，是否显示摘要描述，为true时将会显示页面描述 copy 复制行 没有勾选的单选框 已勾选的单选框 参数：checked: true&#x2F;falsecolor: red&#x2F;orange&#x2F;yellow&#x2F;green&#x2F;cyan&#x2F;blue&#x2F;purple checkbox 复选 普通的没有勾选的复选框 普通的已勾选的复选框 显示为加号的绿色的已勾选的复选框 显示为减号的黄色的已勾选的复选框 显示为乘号的红色的已勾选的复选框 checked: true&#x2F;falsecolor: red&#x2F;orange&#x2F;yellow&#x2F;green&#x2F;cyan&#x2F;blue&#x2F;purplesymbol: plus&#x2F;minus&#x2F;times 内置当行 文章项目留言GitHub 设备 这是 密码 标签 这是 下划线 标签 这是 着重号 标签 这是 波浪线 标签 这是 删除线 标签 这是 上角标 标签 这是 下角标 标签 这是 键盘样式 标签，试一试：⌘ + D 静态时间线：静态数据是写死在 md 源文件中的，在 deploy 时就已经确定了。 2021 年 2 月 16 日主要部分功能已经开发的差不多了。2021 年 2 月 11 日今天除夕，也是生日，一个人在外地过年+过生日，熬夜开发新主题，尽量在假期结束前放出公测版。 原密码 第一步：打开 GitHub打开 Stellar 的 GitHub 页面。第二步：点击 Star如果发现右上角的 Star 还没点亮，就点亮它！ 近期动态（说说） 动态数据是从 GitHub Issues 中拉取的，使用方法为： 建一个仓库创建一个 issue 并添加一个 label 进行测试写 timeline 标签时加上 api:https://api.github.com/repos/your-name/your-repo/issues 设置 user:xxx 则会只显示某人发的 issue 数据，可以用来展示个人动态。 友链文章订阅 嗯，除了 issues 和 releases 数据，时间线还兼容「友链朋友圈」数据，可以展示小伙伴们最近发布的文章： 侧边栏时间线 在 source&#x2F;_data&#x2F;widgets.yml 文件中创建时间线组件：timeline: layout: timeline title: 近期动态 api: https://api.github.com/repos/xaoxuu/blog-timeline/issues?per_page=1 user: xaoxuu timeline_stellar_more: layout: timeline title: Stellar 探索号 api: https://api.github.com/repos/xaoxuu/hexo-theme-stellar/issues?state=all&amp;labels=分享&amp;per_page=5 hide: title 然后在需要显示的页面的 front-matter 中的 sidebar 部分写上它的名字，例如本文的配置： sidebar: [toc, timeline_stellar_more] 您可以在任何位置插入友链组，支持静态数据和动态数据，静态数据需要写在数据文件中： friends 友链 blog&#x2F;source&#x2F;_data&#x2F;links.yml‘开源大佬’: - title: 某某某 url: https:&#x2F;&#x2F; screenshot: avatar: description: sites 网站卡片 您可以在任何位置插入网站卡片组，支持静态数据和动态数据，静态数据需要写在数据文件中：blog&#x2F;source&#x2F;_data&#x2F;links.yml‘分组名’: title: 某某某url: https:&#x2F;&#x2F;screenshot:avatar:description: 在需要的位置这样写： 容器类标签（7个） 语法格式 [title] [color:color] [child:codeblock/tabs]… Stellar v1.12.0因为原 noteblock 标签在升级到 hexo 6.0 之后跟官方库冲突了，官方一直没有解释原因，后不得不改名：noteblock -&gt; grid -&gt; border详情见：#172 1sdfs &lt;center&gt; &lt;/br&gt; &lt;script type=&quot;text/javascript&quot;&gt; function show_runtime() &#123; window.setTimeout(&quot;show_runtime()&quot;, 1000); X = new Date(&quot;9/15/2023 00:00:00&quot;); Y = new Date(); T = (Y.getTime() - X.getTime()); M = 24 * 60 * 60 * 1000; a = T / M; A = Math.floor(a); b = (a - A) * 24; B = Math.floor(b); c = (b - B) * 60; C = Math.floor((b - B) * 60); D = Math.floor((c - C) * 60); runtime_span.innerHTML = &quot;⏱️本站已艰难运行 &quot; + A + &quot;天&quot; + B + &quot;小时&quot; + C + &quot;分&quot; + D + &quot;秒&quot; &#125; show_runtime(); &lt;/script&gt; &lt;span id=&quot;runtime_span&quot;&gt;&lt;/span&gt; &lt;/center&gt; &lt;center&gt; &lt;/br&gt; &lt;script type=&quot;text/javascript&quot;&gt; function show_runtime() &#123; window.setTimeout(&quot;show_runtime()&quot;, 1000); X = new Date(&quot;9/15/2023 00:00:00&quot;); Y = new Date(); T = (Y.getTime() - X.getTime()); M = 24 * 60 * 60 * 1000; a = T / M; A = Math.floor(a); b = (a - A) * 24; B = Math.floor(b); c = (b - B) * 60; C = Math.floor((b - B) * 60); D = Math.floor((c - C) * 60); runtime_span.innerHTML = &quot;⏱️本站已艰难运行 &quot; + A + &quot;天&quot; + B + &quot;小时&quot; + C + &quot;分&quot; + D + &quot;秒&quot; &#125; show_runtime(); &lt;/script&gt; &lt;span id=&quot;runtime_span&quot;&gt;&lt;/span&gt; &lt;/center&gt; &#123;% tabs active:3 %&#125; &#123;% timeline %&#125; 本地git+server+nginx方式部署调试。 [阿里云](https://wanwang.aliyun.com/)注册域名！ &#123;% endtimeline %&#125; ## 愿望清单 &#123;% grid bg: %&#125; &#123;% image https://images.unsplash.com/photo-1625171515821-1870deb2743b?ixlib=rb-4.0.3&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&fit=crop&w=774&q=80 width:200px %&#125; Unsplash Photo The Galactic Center is the rotational center of the Milky Way galaxy. Its central massive object is a supermassive black hole of about 4 million solar masses, which is called Sagittarius A*. Its mass is equal to four million suns. The center is > located 25,800 light years away from Earth. &#123;% endgrid %&#125; &#123;% swiper effect:cards %&#125; &#123;% image https://images.unsplash.com/photo-1625171515821-1870deb2743b?ixlib=rb-4.0.3&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&fit=crop&w=774&q=80 %&#125; &#123;% image https://images.unsplash.com/photo-1528283648649-33347faa5d9e?ixlib=rb-4.0.3&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&fit=crop&w=774&q=80 %&#125; &#123;% image https://images.unsplash.com/photo-1542272201-b1ca555f8505?ixlib=rb-4.0.3&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&fit=crop&w=774&q=80 %&#125; &#123;% image https://images.unsplash.com/photo-1524797905120-92940d3a18d6?ixlib=rb-4.0.3&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&fit=crop&w=774&q=80 %&#125; &#123;% endswiper %&#125; ## 说说 &#123;% timeline hide:title,footer user:czsmall api:https://api.github.com/repos/czsmall/shuoshuo/issues?direction=asc&per_page=3 %&#125;&#123;% endtimeline %&#125; &#123;% endtabs %&#125; content: | # 支持 Markdown 格式 function show_runtime() { window.setTimeout(\"show_runtime()\", 1000); X = new Date(\"9/15/2023 00:00:00\"); Y = new Date(); T = (Y.getTime() - X.getTime()); M = 24 * 60 * 60 * 1000; a = T / M; A = Math.floor(a); b = (a - A) * 24; B = Math.floor(b); c = (b - B) * 60; C = Math.floor((b - B) * 60); D = Math.floor((c - C) * 60); runtime_span.innerHTML = \"⏱️本站已艰难运行 \" + A + \"天\" + B + \"小时\" + C + \"分\" + D + \"秒\" } show_runtime(); content: | # 支持 Markdown 格式 &lt;center&gt; &lt;div style=&quot;margin:0.2rem;&quot;&gt; &lt;a href=&quot;https://travellings.link&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://img.shields.io/badge/Travellings-开往--友链接力-86CAF2&quot; alt=&quot;Travellings&quot; /&gt;&lt;/a&gt; &lt;a href=&quot;https://www.foreverblog.cn/go.html&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://img.shields.io/badge/Wormhole-十年之约-D09968&quot; alt=&quot;穿梭虫洞--随机访问十年之约友链博客&quot; /&gt;&lt;/a&gt; &lt;/div&gt; &lt;br&gt; &lt;/br&gt; &lt;script type=&quot;text/javascript&quot;&gt; function show_runtime() &#123; window.setTimeout(&quot;show_runtime()&quot;, 1000); X = new Date(&quot;9/15/2023 00:00:00&quot;); Y = new Date(); T = (Y.getTime() - X.getTime()); M = 24 * 60 * 60 * 1000; a = T / M; A = Math.floor(a); b = (a - A) * 24; B = Math.floor(b); c = (b - B) * 60; C = Math.floor((b - B) * 60); D = Math.floor((c - C) * 60); runtime_span.innerHTML = &quot;⏱️本站已艰难运行 &quot; + A + &quot;天&quot; + B + &quot;小时&quot; + C + &quot;分&quot; + D + &quot;秒&quot; &#125; show_runtime(); &lt;/script&gt; &lt;span id=&quot;runtime_span&quot;&gt;&lt;/span&gt; &lt;/center&gt; &#123;% timeline hide:title,footer user:czsmall limit:7 api:https://api.github.com/repos/czsmall/shuoshuo/issues?direction=asc& %&#125;&#123;% endtimeline %&#125;? direction=asc&amp; 倒叙","tags":["未知"],"categories":["未知"]},{"title":"Hello World","path":"/2023/09/13/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment"},{"path":"/README.html","content":"opshxx.github.io"},{"path":"/about/index.html","content":"Hello.苦难不值得被歌颂，但希望永远值得被追捧友链留言 小站历程愿望清单说说2023 年 10 月 22 日基于GitHub Action实现动态友链订阅,看教程点点点2023 年 10 月 16 日本地git+server+nginx方式部署调试。2023 年 9 月 2 日 阿里云注册域名！ 愿望清单Unsplash PhotoThe Galactic Center is the rotational center of the Milky Way galaxy. Its central massive object is a supermassive black hole of about 4 million solar masses, which is called Sagittarius A*. Its mass is equal to four million suns. The center islocated 25,800 light years away from Earth. 说说"},{"path":"/bibi/index.html","content":"#?direction&#x3D;asc&amp;（放在issues后面可以实现倒叙）"},{"path":"/friends/index.html","content":"Hello. I’m Ant.对于可控的事情，要保持谨慎，对于不可控的事情，要保持乐观，人只能做自己能力范围内的事情，你要接受这个事实，并且以乐观的心去应对这一切； 友链留言 未雨筹谋GO-LINUX运维世界王先森XAOXUU酷小呵小白 友链动态 海内存知己，天涯若比邻未雨筹谋GO-LINUX运维世界王先森XAOXUU酷小呵小白 测试github同步 22号同步"},{"path":"/news/index.html","content":"20232022 2021 年 2 月 16 日博客基本完成2021 年 2 月 11 日测试页"},{"path":"/notes/index.html","content":"Hello. I’m Ant.对于可控的事情，要保持谨慎，对于不可控的事情，要保持乐观，人只能做自己能力范围内的事情，你要接受这个事实，并且以乐观的心去应对这一切； 官方文档技术支持 内容"},{"path":"/friends/rss/index.html","content":""},{"path":"/news/2021/index.html","content":"20222023"},{"path":"/news/2022/index.html","content":"20222023"},{"title":"标签o1","path":"/notes/n2/index.html","content":"sda faf af sf a"},{"title":"名称222","path":"/notes/n1/index.html","content":"sda faf af sf a"},{"path":"/wiki/docker/01.默认页.html","content":"Docker容器学习目标： 掌握Docker基础知识，能够理解Docker镜像与容器的概念 完成Docker安装与启动 掌握Docker镜像与容器相关命令 掌握Tomcat Nginx 等软件的常用应用的安装 掌握docker迁移与备份相关命令 能够运用Dockerfile编写创建容器的脚本 能够搭建与使用docker私有仓库 Docker 资源汇总 Docker 官方主页: https://www.docker.com Docker 官方博客: https://blog.docker.com/ Docker 官方文档: https://docs.docker.com/ Docker Store: https://store.docker.com Docker Cloud: https://cloud.docker.com Docker Hub: https://hub.docker.com Docker 的源代码仓库: https://github.com/moby/moby Docker 发布版本历史: https://docs.docker.com/release-notes/ Docker 常见问题: https://docs.docker.com/engine/faq/ Docker 远端应用 API: https://docs.docker.com/develop/sdk/ Docker 国内镜像阿里云的加速器：https://help.aliyun.com/document_detail/60750.html 网易加速器：http://hub-mirror.c.163.com 官方中国加速器：https://registry.docker-cn.com ustc 的镜像：https://docker.mirrors.ustc.edu.cn daocloud：https://www.daocloud.io/mirror#accelerator-doc（注册后使用） 如果有更好的资源，欢迎通过下面的笔记来分享。"},{"title":"Docker简介与安装","path":"/wiki/docker/02.Docker安装与简介.html","content":"学习目标： 掌握Docker基础知识，能够理解Docker镜像与容器的概念 完成Docker安装与启动 掌握Docker镜像与容器相关命令 掌握Tomcat Nginx 等软件的常用应用的安装 掌握docker迁移与备份相关命令 能够运用Dockerfile编写创建容器的脚本 能够搭建与使用docker私有仓库 一、Docker简介1.1 什么是虚拟化虚拟化，是指通过虚拟化技术将一台计算机虚拟为多台逻辑计算机。在一台计算机上同时运行多个逻辑计算机，每个逻辑计算机可运行不同的操作系统，并且应用程序都可以在相互独立的空间内运行而互不影响，从而显著提高计算机的工作效率。 虚拟化技术种类很多，例如：软件虚拟化、硬件虚拟化、内存虚拟化、网络虚拟化(vip)、桌面虚拟化、服务虚拟化、虚拟机等等。 问题：为什么会有docker出现？ 一款产品从开发到上线，从操作系统，到运行环境，再到应用配置。作为开发+运维之间的协作我们需要关心很多东西，这也是很多互联网公司都不得不面对的问题，特别是各种版本的迭代之后，不同版本环境的兼容，对运维人员都是考验 , 这个时候 Docker 横空出世，是因为它对此给出了一个标准化的解决方案。 环境配置如此麻烦，换一台机器，就要重来一次，费力费时。很多人想到，能不能从根本上解决问题，软件可以带环境安装？也就是说，安装的时候，把原始环境一模一样地复制过来。开发人员利用 Docker 可以消除协作编码时“在我的机器上可正常工作”的问题。 之前，可以发现，每发布一个程序，都要走一遍以上的流程： 1.2 什么是DockerDocker 是一个开源的应用容器引擎，基于 Go 语言开发。Docker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口（类似 iPhone 的 app）,更重要的是容器性能开销极低。 Docker的主要目标是“Build，Ship and Run Any App,Anywhere”，也就是通过对应用组件的封装、分发、部署、运行等生命周期的管理，使用户的APP（可以是一个WEB应用或数据库应用等等）及其运行环境能够做到“一次封装，到处运行”。 总之一句话：只需要一次配置好环境，换到别的机子上就可以一键部署好，大大简化了操作 。 为什么选择Docker? Docker的镜像提供了除内核外完整的运行时环境，确保了应用运行环境一致性，从而不会再出现“这段代码在我机器上没问题啊”这类问题；——一致的运行环境 可以做到秒级、甚至毫秒级的启动时间。大大的节约了开发、测试、部署的时间。——更快速的启动时间 避免公用的服务器，资源会容易受到其他用户的影响。——隔离性 善于处理集中爆发的服务器使用压力；——弹性伸缩，快速扩展 可以很轻易的将在一个平台上运行的应用，迁移到另一个平台上，而不用担心运行环境的变化导致应用无法正常运行的情况。——迁移方便 使用Docker可以通过定制应用镜像来实现持续集成、持续交付、部署。——持续交付和部署 Docker应用场景 ① Web 应用的自动化打包和发布 ② 自动化测试和持续集成、发布 ③ 在服务型环境中部署和调整数据库或其他的后台应用 使用Docker可以实现开发人员的开发环境、测试人员的测试环境、运维人员的生产环境的一致性。 Docker借鉴了标准集装箱的概念。标准集装箱将货物运往世界各地，Docker将这个模型运用到自己的设计中，唯一不同的是：集装箱运输货物，而Docker运输软件。 1.3 容器与虚拟机比较下面的图片比较了 Docker 和传统虚拟化方式的不同之处，可见容器是在操作系统层面上实现虚拟化，直接复用本地主机的操作系统，而传统方式则是在硬件层面实现。 传统虚拟机 传统虚拟机技术基于安装在主操作系统上的虚拟机管理系统（如：VirtualBox和VMWare等），创建虚拟机（虚拟出各种硬件），在虚拟机上安装从操作系统，在从操作系统中安装部署各种应用。 Docker Docker容器是在操作系统层面上实现虚拟化，直接复用本地主机的操作系统，而传统虚拟机则是在硬件层面实现虚拟化。与传统的虚拟机相比，Docker优势体现为启动速度快、占用体积小。 使用上的区别 简单来说： 容器和虚拟机具有相似的资源隔离和分配优势，但功能有所不同，因为容器虚拟化的是操作系统，而不是硬件，因此容器更容易移植，效率也更高。 1.4 Docker 组件1.4.1 Docker组成部分Docker是一个客户端-服务器（C&#x2F;S）架构程序。Docker客户端只需要向Docker服务器或者守护进程发出请求，服务器或者守护进程将完成所有工作并返回结果。Docker提供了一个命令行工具Docker以及一整套RESTful API。你可以在同一台宿主机上运行Docker守护进程和客户端，也可以从本地的Docker客户端连接到运行在另一台宿主机上的远程Docker守护进程。 1.4.2 Docker镜像与容器镜像：类似虚拟机镜像 , 是一个特殊的文件系统 操作系统分为内核和用户空间。对于Linux而言，内核启动后，会挂载root文件系统为其提供用户空间支持。而Docker镜像（Image），就相当于是一个root文件系统。 Docker镜像是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。 镜像不包含任何动态数据，其内容在构建之后也不会被改变。 容器：类似linux系统环境，运行和隔离应用。是镜像运行时的实体 镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中的类和实例一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等 。 仓库：集中存放镜像文件的地方。 镜像构建完成后，可以很容易的在当前宿主上运行，但是， 如果需要在其它服务器上使用这个镜像，我们就需要一个集中存储、分发镜像的地方，比如后面我们要学的，Docker Registry就是这样的服务。 1.4.3 Registry（注册中心）Docker用Registry来保存用户构建的镜像。Registry分为公共和私有两种。Docker公司运营公共的Registry叫做Docker Hub。用户可以在Docker Hub注册账号，分享并保存自己的镜像（说明：在Docker Hub下载镜像巨慢，可以自己构建私有的Registry）。 https://hub.docker.com/ 二、Docker安装与启动2.1 安装Docker-CentOS7Docker官方建议在Ubuntu中安装，因为Docker是基于Ubuntu发布的，而且一般Docker出现的问题Ubuntu是最先更新或者打补丁的。在很多版本的CentOS中是不支持更新最新的一些补丁包的。​ 由于我们学习的环境都使用的是CentOS，因此这里我们将Docker安装到CentOS上。 注意：这里建议安装在CentOS7.x以上的版本，在CentOS6.x的版本中，安装前需要安装其他很多的环境，而且Docker很多补丁不支持更新。 官网中文安装参考手册 https://docs.docker.com/install/linux/docker-ce/centos/ 确定你是CentOS7及以上版本 cat &#x2F;etc&#x2F;redhat-release yum安装gcc相关 CentOS7能上外网 检查gcc和g++是否安装好，如果没有安装好，则需要安装。 安装gcc和g++ yum -y install gcc yum -y install gcc-c++ 安装需要的软件包 yum install -y yum-utils device-mapper-persistent-data lvm2 1yum install -y yum-utils device-mapper-persistent-data lvm2 设置镜像仓库 大坑(千万不要试，网速慢，超时，安装不上) yum-config-manager –add-repo （centos快速添加yum源）https://download.docker.com/linux/centos/docker-ce.repo 报错：官网太慢，一定超时。 [Errno 14] curl#35 - TCP connection reset by peer [Errno 12] curl#35 - Timeout 推荐：阿里云服务器 yum-config-manager –add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo 更新yum软件包索引 yum makecache fast 安装DOCKER CE（社区版）（DOCKER EE企业版收费） yum -y install docker-ce 启动docker 手动启动：systemctl start docker 自动启动：systemctl enable docker 测试 检查版本：docker version 下载并运行HelloWorld：docker run hello-world 如果下载不下来，可以配置镜像加速器 输出这段提示以后，hello world就会停止运行，容器自动终止。 run干了什么 配置镜像加速CentOS7版本 mkdir -p &#x2F;etc&#x2F;docker vim &#x2F;etc&#x2F;docker&#x2F;daemon.json #网易云 { “registry-mirrors”: [“http://hub-mirror.c.163.com“] } #阿里云(推荐) { “registry-mirrors”: [“https://8y2y8njn.mirror.aliyuncs.com“] } #ustc #是老牌的linux镜像服务提供者了，还在遥远的ubuntu 5.04版本的时候就在用。ustc的docker镜像加速器速度很快。 #ustc docker mirror的优势之一就是不需要注册，是真正的公共服务。 #https://lug.ustc.edu.cn/wiki/mirrors/help/docker 在该文件中输入如下内容： { “registry-mirrors”: [“https://docker.mirrors.ustc.edu.cn“] } systemctl daemon-reload systemctl restart docker 卸载 systemctl stop docker yum -y remove docker-ce rm -rf &#x2F;var&#x2F;lib&#x2F;docker 卸载旧版本 2019.11英文官网版本 最新的英文版：https://docs.docker.com/install/linux/docker-ce/centos/\\#uninstall-old-versions yum remove docker \\ docker-client \\ docker-client-latest \\ docker-common \\ docker-latest \\ docker-latest-logrotate \\ docker-logrotate \\ docker-engine 2.2 Docker的启动与停止2.2.1 命令 启动docker： systemctl start docker 停止docker： systemctl stop docker 重启docker： systemctl restart docker 查看docker状态： systemctl status docker 开机启动： systemctl enable docker 查看docker概要信息： docker info 查看docker帮助文档： docker –help 2.2.2 帮助手册：docker –help 2.2.3 指令介绍 cp 本地文件系统(OS操作系统|宿主机)和容器之间进行文件或者文件夹拷贝 exec 登录一个容器，使用命令行操作正在运行的容器。 images 镜像的集合查询。 ps 容器列表 pull 下载镜像 restart 重启一个或多个容器 rm 删除一个或多个容器 rmi 删除一个或多个镜像 run 创建一个容器，并运行起来 save 导出镜像到一个文件(tar)中 search 搜索镜像（从Docker Hub） start 启动一个或多个已经停止的容器 stop 停止一个或多个正在运行的容器"},{"title":"Docker镜像管理","path":"/wiki/docker/03.Docker镜像管理.html","content":"镜像：Docker镜像是由文件系统叠加而成（是一种文件的存储形式）；是docker中的核心概念，可以认为镜像就是对某些运行环境或者软件打的包，用户可以从docker仓库中下载基础镜像到本地，比如，开发人员可以从docker仓库拉取（下载）一个只包含centos7系统的基础镜像，然后在这个镜像中安装jdk、mysql、Tomcat和自己开发的应用，最后将这些环境打成一个新的镜像。开发人员将这个新的镜像提交给测试人员进行测试，测试人员只需要在测试环境下运行这个镜像就可以了，这样就可以保证开发人员的环境和测试人员的环境完全一致。 1 镜像相关命令1.1 查看镜像查看镜像可以使用如下命令：docker images REPOSITORY：镜像名称 TAG：镜像标签（版本） IMAGE ID：镜像ID CREATED：镜像的创建日期（不是获取该镜像的日期） SIZE：镜像大小 这些镜像都是存储在Docker的 &#x2F;var&#x2F;lib&#x2F;docker 目录下 1.2 搜索镜像从网络中查找需要的镜像：docker search 镜像名称 例如 下载一个 nginx 镜像 NAME：仓库名称 DESCRIPTION：镜像描述 STARS：用户评价，反应一个镜像的受欢迎程度 OFFICIAL：是否官方 AUTOMATED：自动构建，表示该镜像由Docker Hub自动构建流程创建 1.3 拉取镜像拉取镜像就是从Docker仓库下载镜像到本地，镜像名称格式为 【名称:版本号】，如果版本号不指定则是最新的版本 命令：docker pull 镜像名称下载一个 nginx 的镜像 , 需要注意：如果下载的时候，不指定版本，会下载最新版本 刚刚下载的镜像通过 docker images 就可以查看 1.4 删除镜像可以按照镜像id删除镜像，命令如下：docker rmi 镜像ID 删除单个镜像(-f 强制删除)：docker rmi -f 镜像ID 删除多个镜像：docker rmi -f 镜像名1:TAG 镜像名2:TAG 删除所有镜像：docker rmi -f $(docker images -qa) 1.5从Docker Hub拉取Docker镜像首页，包括官方镜像和其它公开镜像。Docker Hub上最受欢迎的10大镜像（通过Docker registry API获取不了镜像被pull的个数，只能通过镜像的stars数量来衡量镜像的流行度。毫无疑问，拥有最高stars数量的库都是官方库）。 https://hub.docker.com/search?image_filter=official&amp;type=image 国情的原因，国内下载 Docker HUB 官方的相关镜像比较慢，可以使用国内（docker.io）的一些镜像加速器，镜像保持和官方一致，关键是速度快，推荐使用。"},{"title":"Docker容器封装","path":"/wiki/docker/04.Docker容器封装.html","content":"3.2 容器相关命令 容器也是docker中的核心概念，镜像是创建容器的软件 , 容器是由镜像运行产生的运行实例。镜像和容器的关系，就如同Java语言中类和对象的关系。 如果需要通俗的描述容器的话，我觉得容器就是一个存放东西的地方，就像书包可以装各种文具、衣柜可以放各种衣服、鞋架可以放各种鞋子一样。我们现在所说的容器存放的东西可能更偏向于应用。比如网站、程序甚至是系统环境。 1.1 查看容器 查看正在运行的容器： docker ps 查看所有容器： docker ps –a 查看最后一次运行的容器： docker ps –l 查看停止的容器： docker ps -f status&#x3D;exited 1.2 创建与启动容器① 什么是宿主机？ 就是主机，这个概念是相对于子机而言的，比如你安装有虚拟机的话，那么相对于虚拟机而言，你正在使用的计算机就是宿主机，虚拟机是安装在主机上的，必须在主机上才能运行，主机就是一个“宿主”。 ② 创建容器常用的参数说明： 创建容器命令：docker run -i：表示运行容器 -t：表示容器启动后会进入其命令行。加入这两个参数后，容器创建就能登录进去。即分配一个伪终端。 –name :为创建的容器命名。 -v：表示目录映射关系（前者是宿主机目录，后者是映射到宿主机上的目录），可以使用多个－v做多个目录或文件映射。注意：最好做目录映射，在宿主机上做修改，然后共享到容器上。 -d：在run后面加上-d参数,则会创建一个守护式容器在后台运行（这样创建容器后不会自动登录容器，如果只加-i -t两个参数，创建后就会自动进去容器）。 -p：表示端口映射，前者是宿主机端口，后者是容器内的映射端口。可以使用多个-p做多个端口映射 （1）交互式方式创建容器 以交互式方式创建并启动容器，启动完成后，直接进入当前容器。使用exit命令退出容器。需要注意的是以此种方式启动容器，如果退出容器，则容器会进入停止状态。可以理解成交互式容器 是前台容器。 1234567docker run -it --name=容器名称 镜像名称:标签 /bin/bash# 比如：docker run -it --name=mycentos centos:7 /bin/bash# docker run:表示创建容器# -it：表示运行容器并进入它的命令行# --name=mycentos：给当前的容器命名# centos:7：使用该镜像创建# /bin/bash：放在镜像名后的是命令，这里我们希望有个交互式 Shell，因此用的是 /bin/bash 创建好容器，并且已经进入到容器内部了，可以直接观察前面中括号里面的内容发现，跟创建容器之前不一样了， 并且 通过 dir 命令，会发现，其实容器内部也是一个 centos , 我们可以把每个容器都看成一个小电脑或者服务器 重新开一个新的会话，查看刚刚创建的容器是否已经有了。 查看正在运行的容器：docker ps 退出当前容器：exit 退出之后，容器也退出了，没有删除 (2) 创建后台容器 docker run -id –name&#x3D;mycentos2 centos:7 查看 docker 容器已经运行 (3) 守护式方式创建容器： 创建一个守护式容器；如果对于一个需要长期运行的容器来说，我们可以创建一个守护式容器。 命令如下（容器名称不能重复）：守护容器可以理解成在后台运行的容器 12345# 守护式容器和交互式容器的创建方式区别：# ① -it 换成 -di# ② 去掉后面的 /bin/bashdocker run -di --name=容器名称 镜像名称:标签# 比如：docker run -di --name=mycentos10 centos:7 通过 docker ps 查看容器已经是运行状态 进入守护式容器方式： 12docker exec -it 容器名称 (或者容器ID) /bin/bash# 比如 docker exec -it mycentos10 /bin/bash 已经进入到容器内部了，如果现在退出exit，然后查看容器docker ps是否还在后台运行（仍在运行） 1.3 停止与启动容器 先通过 docker ps 查看正在运行的容器 停止容器： docker stop 容器名称（或者容器ID） 例如： docker stop mycentos2 创建完容器之后，停止容器 查看容器是否已经停止 启动容器： docker start 容器名称（或者容器ID） 例如： docker start mycentos2 （以交互式运行的容器，只是第一次exit退出的时候会关闭容器，当用start启动的时候，就相当于后台启动了，exec进去之后再exit退出不会关闭容器） 查看容器是否已经启动 1.4 文件拷贝我们需要在容器内安装一个软件，软件首先需要有安装包，我们就需要把安装包拷贝到容器内。我们通常的操作是先把文件上传到宿主机，然后我们在将文件从宿主机拷贝到容器内的某个目录下面进行安装。 将linux宿主机中的文件拷贝到容器内可以使用命令： 如果我们需要将文件拷贝到容器内可以使用cp命令 docker cp 需要拷贝的文件或目录 容器名称:容器目录 例如： docker cp anaconda-ks.cfg mycentos2:&#x2F;usr&#x2F;local&#x2F; 拷贝一个文件到 mycentos2 的 &#x2F;urs&#x2F;local&#x2F; 文件下面 ，拷贝完成之后，删除文件，然后在mycentos2拷贝过来 登录容器查看拷贝之后的结果 docker exec -it mycentos2 &#x2F;bin&#x2F;bash docker exec：表示登陆正在运行的容器 -it：进入命令行 mycentos2：进入到该容器 也可以将文件从容器内拷贝出来 docker cp 容器名称:容器目录 需要拷贝的文件或目录 例如：docker cp mycentos2:&#x2F;usr&#x2F;local&#x2F;anaconda-ks.cfg .&#x2F; 我们先通过 exit 退出容器，然后在把文件从容器拷贝到当前目录 1.5 目录挂载我们可以在创建容器的时候，将宿主机的目录与容器内的目录进行映射，这样我们就可以通过修改宿主机某个目录的文件从而去影响容器。 创建容器 添加-v参数 后边为 宿主机目录:容器目录，例如： # 创建并启动容器mycentos3,并挂载linux中的&#x2F;usr&#x2F;local&#x2F;myhtml目录到容器的&#x2F;usr&#x2F;local&#x2F;myhtml；也就是在linux中的&#x2F;usr&#x2F;local&#x2F;myhtml中操作相当于对容器相应目录操作 docker run -di –name&#x3D;容器的名字 -v &#x2F;usr&#x2F;local&#x2F;myhtml:&#x2F;usr&#x2F;local&#x2F;myhtml centos:7 比如：docker run -di –name&#x3D;mycentos3 -v &#x2F;usr&#x2F;local&#x2F;myhtml:&#x2F;usr&#x2F;local&#x2F;myhtml centos:7 通过 docker ps 查看正在运行的容器，在创建容器并且进行目录挂载，然后在通过 docker ps 查看刚刚创建的容器是否已经创建 进入到 myhtml 目录 ，通过dir查看是否有文件，通过vi test2 ，创建一个文件，进入test2文件，随便输入一些数据 进入目录随便输入一些东西 ， 退出保存 登录容器，查看刚刚输入的内容 hsg sdg d"},{"title":"Dockerfile","path":"/wiki/docker/05.Dockerfile.html","content":"一、什么是镜像？镜像可以看成是由多个镜像层叠加起来的一个文件系统（通过UnionFS与AUFS文件联合系统实现），镜像层也可以简单理解为一个基本的镜像，而每个镜像层之间通过指针的形式进行叠加。 根据上图，镜像层的主要组成部分包括镜像层 ID、镜像层指针 「指向父层」、元数据「 Layer Metadata，包含了 Docker 构建和运行的信息和父层的层次信息」。只读层和读写层「Top Layer」的组成部分基本一致，同时读写层可以转换成只读层「 通过docker commit 操作实现」。 元数据（metadata）就是关于这个层的额外信息，它不仅能够让Docker获取运行和构建时的信息，还包括父层的层次信息。需要注意，只读层和读写层都包含元数据。 每一层都包括了一个指向父层的指针。如果一个层没有这个指针，说明它处于最底层。 在docker主机中镜像层（image layer）的元数据被保存在名为”json”的文件中，一个容器的元数据好像是被分成了很多文件，但或多或少能够在&#x2F;var&#x2F;lib&#x2F;docker&#x2F;containers&#x2F;目录下找到，就是一个可读层的id。这个目录下的文件大多是运行时的数据，比如说网络，日志等等。 镜像是一堆只读层的统一视角，除了最底层没有指向外，每一层都指向它的父层。统一文件系统（ Union File System）技术能够将不同的层整合成一个文件系统，为这些层提供了一个统一的视角，这样就隐藏了多层的存在。在用户的角度看来，只存在一个文件系统。镜像每一层都是不可写的，都是只读层。 我们可以看到镜像包含多个只读层，它们重叠在一起。除了最下面一层，其它层都会有一个指针指向下一层。这些层是Docker内部的实现细节，并且能够在docker主机的文件系统上访问到。统一文件系统（union file system，升级版为AUFS）技术能够将不同的层整合成一个文件系统，为这些层提供了一个统一的视角，这样就隐藏了多层的存在，在用户的角度看来，只存在一个文件系统。 二、什么是DockerfileDockerfile 是由一系列命令和参数构成的脚本，这些命令应用于基础镜像并最终创建一个新的镜像。它们简化了从头到尾的流程并极大的简化了部署工作。Dockerfile 从 FROM 命令开始，紧接着跟随着各种方法，命令和参数。其产出为一个新的可以用于创建容器的镜像。 Dockerfile 语法由两部分构成，注释和命令+参数，注释是不能少的,因为明天可能就忘记写的是什么了。说白了, Dockerfile 是告诉 docker 怎么样制作一个镜像,就像我们写代码告诉应用怎么执行一条逻辑,这样应该好理解了，所以可以在 Dockerfile 中写明,我们需要怎么个执行方式的某个镜像,最后执行 docker build 命令构建写好的Dockerfile 成镜像。 三、 Dockerfile基础命令3.1、 FROM：功能为指定基础镜像，并且必须是第一条指令。 如果不以任何镜像为基础，写法为：FROM scratch。 同时意味着接下来所写的指令将作为镜像的第一层开始 语法： FROM FROM : 其中 是可选项，如果没有选择，那么默认值为latest 3.2、 MAINTAINER指定作者 语法： MAINTAINER 3.3、 LABEL功能是为镜像指定标签 语法： LABEL &#x3D; &#x3D; &#x3D; … 一个Dockerfile种可以有多个LABEL，如下： 123456789101112131415161718LABEL &quot;com.example.vendor&quot;=&quot;ACME Incorporated&quot;LABEL com.example.label-with-value=&quot;foo&quot;LABEL version=&quot;1.0&quot;LABEL description=&quot;This text illustrates \\that label-values can span multiple lines.&quot;但是并不建议这样写，最好就写成一行，如太长需要换行的话则使用\\符号如下：LABEL multi.label1=&quot;value1&quot; \\multi.label2=&quot;value2&quot; \\other=&quot;value3&quot;注意：LABEL会继承基础镜像种的LABEL，如遇到key相同，则值覆盖 3.4、 RUN功能为运行指定的命令 RUN命令有两种格式 RUN RUN [“executable”, “param1”, “param2”] 第一种后边直接跟shell命令 在linux操作系统上默认 &#x2F;bin&#x2F;sh -c 第二种是类似于函数调用。 可将executable理解成为可执行文件，后面就是两个参数。 两种写法比对： RUN &#x2F;bin&#x2F;bash -c ‘source $HOME&#x2F;.bashrc; echo $HOME RUN [“&#x2F;bin&#x2F;bash”, “-c”, “echo hello”] 注意：多行命令不要写多个RUN，原因是Dockerfile中每一个指令都会建立一层. RUN书写时的换行符是 \\ 多少个RUN就构建了多少层镜像，会造成镜像的臃肿、多层，不仅仅增加了构件部署的时间，还容易出错。 3.5、 ADD一个复制命令，把文件复制到镜像中 如果把虚拟机与容器想象成两台linux服务器的话，那么这个命令就类似于scp，只是scp需要加用户名和密码的权限验证，而ADD不用 1234567891011121314151617181920212223242526272829303132语法如下：ADD &lt;src&gt;... &lt;dest&gt;&lt;src&gt;可以是一个本地文件或者是一个本地压缩文件，还可以是一个url&lt;dest&gt;路径的填写可以是容器内的绝对路径，也可以是相对于工作目录的相对路径ADD test1.txt test1.txtADD test1.txt test1.txt.bakADD test1.txt /mydir/ADD data1 data1ADD zip.tar /myzip有如下注意事项：1、如果源路径是个文件，且目标路径是以 / 结尾， 则docker会把目标路径当作一个目录，会把源文件拷贝到该目录下。如果目标路径不存在，则会自动创建目标路径。2、如果源路径是个文件，且目标路径不是以 / 结尾，则docker会把目标路径当作一个文件。3、如果目标路径不存在，会以目标路径为名创建一个文件，内容同源文件；4、如果目标文件是个存在的文件，会用源文件覆盖它，当然只是内容覆盖，文件名还是目标文件名。5、如果目标文件实际是个存在的目录，则会源文件拷贝到该目录下。 注意，这种情况下，最好显示的以 / 结尾，以避免混淆。6、如果源路径是个目录，且目标路径不存在，则docker会自动以目标路径创建一个目录，把源路径目录下的文件拷贝进来。如果目标路径是个已经存在的目录，则docker会把源路径目录下的文件拷贝到该目录下。7、如果源文件是个归档文件（压缩文件），则docker会自动帮解压。尽量不要把&lt;scr&gt;写成一个文件夹，如果&lt;src&gt;是一个文件夹了，复制整个目录的内容,包括文件系统元数据 3.6、COPY复制命令 语法如下： COPY … COPY [“”,… “”] 与ADD的区别, COPY的只能是本地文件，其他用法一致 3.7、 VOLUME可实现挂载功能，可以将内地文件夹或者其他容器种得文件夹挂在到这个容器种 语法为： VOLUME [“&#x2F;data”] 说明： [“&#x2F;data”]可以是一个JsonArray ，也可以是多个值。所以如下几种写法都是正确的 VOLUME [“&#x2F;var&#x2F;log&#x2F;“] VOLUME &#x2F;var&#x2F;log VOLUME &#x2F;var&#x2F;log &#x2F;var&#x2F;db 一般的使用场景为需要持久化存储数据时, 容器使用的是AUFS，这种文件系统不能持久化数据，当容器关闭后，所有的更改都会丢失，所以当数据需要持久化时用这个命令。 3.8、 EXPOSE功能为暴漏容器运行时的监听端口给外部 但是EXPOSE并不会使容器访问主机的端口 如果想使得容器与主机的端口有映射关系，必须在容器启动的时候加上 -P参数 3.9、 WORKDIR设置工作目录 语法： WORKDIR &#x2F;usr&#x2F;bin&#x2F; 3.10、 ENV功能为设置环境变量 语法有两种 ENV ENV &#x3D; … 两者的区别就是第一种是一次设置一个，第二种是一次设置多个 3.11、 CMD功能为容器启动时要运行的命令 语法有三种写法 CMD [“executable”,“param1”,“param2”] CMD [“param1”,“param2”] CMD command param1 param2 第三种比较好理解了，就时shell这种执行方式和写法 第一种和第二种其实都是可执行文件加上参数的形式 举例说明两种写法： CMD [ “sh”, “-c”, “echo $HOME” CMD [ “echo”, “$HOME” ] 注意： 1、这里边包括参数的一定要用双引号，就是 “ 不能是单引号, 原因是参数传递后，docker解析的是一个JSON Array 2、不要把RUN和CMD搞混了。 RUN：是构件容器时就运行的命令以及提交运行结果 CMD：是容器启动时执行的命令，在构件时并不运行 3.12、 ENTRYPOINT功能是启动时的默认命令 语法如下： ENTRYPOINT [“executable”, “param1”, “param2”] ENTRYPOINT command param1 param2 如果从上到下看到这里的话，那么你应该对这两种语法很熟悉啦。 第一种就是可执行文件加参数 第二种就是写shell 1234567891011121314151617181920212223242526与 CMD 比较说明：相同点：只能写一条，如果写了多条，那么只有最后一条生效，容器启动时才运行，运行时机相同不同点：ENTRYPOINT 不会被运行的 command 覆盖，而 CMD 则会被覆盖如果我们在 Dockerfile 时同时写了 ENTRYPOINT 和 CMD ，并且 CMD 指令不是一个完整的可执行命令，那么CMD 指定的内容将会作为 ENTRYPOINT 的参数, 如下：FROM centosENTRYPOINT [&quot;top&quot;, &quot;-b&quot;]CMD [&quot;-c&quot;]如果我们在 Dockerfile 种同时写了 ENTRYPOINT 和 CMD ，并且 CMD 是一个完整的指令，那么它们两个会互相覆盖，谁在最后谁生效, 如下：FROM centosENTRYPOINT [&quot;top&quot;, &quot;-b&quot;]CMD ls -al那么将执行 ls -al , top -b 不会执行 四、 Dockerfile 案例12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485861、创建目录，用于存放 dockerfile 所使用的文件2、在此目录中创建 dockerfile 文件3、在此目录中使用 docker build 创建镜像4、使用创建的镜像启动容器准备启动文件：vim httpd-run.sh#!/bashrm -rf /run/httpd/*exec /usr/sbin/httpd -D FOREGROUND准备网页测试文件vim index.htmlhello welcome to zutuanxue!!!准备 dockerfile 文件FROM centos:latestMAINTAINER &quot;zutuanxue admin@163.com&quot; ADD httpd-run.sh /httpd-run.shADD index.html /var/www/html/index.htmlRUN yum -y install httpd &amp;&amp; chmod -v +x /httpd-run.shEXPOSE 80WORKDIR /CMD [&quot;/bin/bash&quot;,&quot;/httpd-run.sh&quot;]创建镜像：docker build -t centos-httpd:v1 . -t: 镜像的名字及标签，通常 name:tag 或者 name 格式#定义基础镜像 FROMFROM centos#定义作者 MAINTAINERMAINTAINER BaiShuming#上传文件到容器 COPY or ADD#COPY 从当前目录复制文件到容器. 只是单纯地复制文件. 格式为 COPY &lt;src&gt; &lt;dest&gt;。#ADD 从当前目录复制文件到容器. 会自动处理目录, 压缩包等情况.格式为 ADD &lt;src&gt; &lt;dest&gt;。ADD nginx-1.17.6.tar.gz /root#生成镜像时运行的命令 RUN#shell 写法RUN yum -y install pcre-devel zlib-devel openssl lsof iproute net-tools gcc make#exec写法#[&quot;命令&quot;,&quot;命令选项&quot;,&quot;参数&quot;]#解压压缩文件#RUN [&quot;tar&quot;,&quot;xf&quot;,&quot;nginx-1.17.6.tar.gz&quot;]#创建管理用户wwwRUN useradd -r -s/sbin/nologin -M www#进入nginx源码文件WORKDIRWORKDIR /root/nginx-1.17.6#安装nginxRUN ./configure --prefix=/usr/local/nginx --user=www --group=www &amp;&amp; make &amp;&amp; make install#定义变量 ENVENV PATH /usr/local/nginx/sbin:$PATH#业务初始化#COPY 从当前目录复制文件到容器. 只是单纯地复制文件. 格式为 COPY &lt;src&gt; &lt;dest&gt;。COPY nginx.conf /usr/local/nginx/confCOPY index.html /usr/local/nginx/html#输出端口 EXPOSEEXPOSE 80#挂载本地目录VOLUME#创建一个可以从本地主机或其他容器挂载的挂载点#一般用来存放数据库和需要保持同步的数据VOLUME [&quot;/data&quot;]#容器启动后执行的命令 CMD#只能执行一个，如果有多个，同一时间只有最后一个生效CMD [&quot;nginx&quot;,&quot;-g&quot;,&quot;daemon off;&quot;]"},{"title":"07.Docker 实例","path":"/wiki/docker/07.Docker实例.html","content":"sidebar: [search, toc] #侧边显示的组件 一、 应用部署1.1 MySQL部署 （1）拉取mysql镜像 docker pull centos&#x2F;mysql-57-centos7 （2）创建容器 # 创建mysql5.7容器 # docker run -di –name&#x3D;容器名字 -p 宿主机端口:容器端口 -e MYSQL_ROOT_PASSWORD&#x3D;mysql密码 容器名称 docker run -di –name&#x3D;mysql5.7 -p 33306:3306 -e MYSQL_ROOT_PASSWORD&#x3D;123456 centos&#x2F;mysql-57-centos7 -p 代表端口映射，格式为 宿主机映射端口:容器运行端口 -e 代表添加环境变量 MYSQL_ROOT_PASSWORD 是root用户远程登陆密码 创建守护式容器 ，并且通过 docker ps 查看是否映射成功， （3）远程登录mysql 连接宿主机的IP ,指定端口为33306 使用 windows上面的小海豚进行连接 navicat 测试连接 创建数据库和数据库里面的表 CREATE DATABASE vue; USE vue; CREATE TABLE USER( id INT PRIMARY KEY AUTO_INCREMENT, age INT, username VARCHAR(20), password VARCHAR(50), email VARCHAR(50), sex VARCHAR(20) ) 1.2 Tomcat部署（1）拉取镜像 docker pull tomcat:7-jre7 （2）创建容器 创建容器 -p表示地址映射 -v 表示目录挂载 # 创建tomcat容器;并挂载了webapps目录 docker run -di –name&#x3D;mytomcat -p 9000:8080 -v &#x2F;usr&#x2F;local&#x2F;webapps:&#x2F;usr&#x2F;local&#x2F;tomcat&#x2F;webapps tomcat:7-jre7 创建完成容器之后，在通过 docker ps 查看容器是否正在运行 本地的war包 ，上传到docker容器里面 ls 查看 dubbo的war 是否已经上传到docker容器，上传成功之后，在通过mv 命令 把dubbo移动到 &#x2F;usr&#x2F;local&#x2F;webapps 目录下面，然后请求 http://192.168.211.144:9000/dubbo-admin-2.6.0/ 请求地址：http://192.168.211.144:9000/dubbo-admin-2.6.0/ 说明咱的tomcat已经部署成功 1.3 Nginx部署（1）拉取镜像 docker pull nginx （2）创建Nginx容器 docker run -di –name&#x3D;mynginx -p 80:80 nginx 安装完成之后，请求nginx页面 1.4 Redis部署（1）拉取镜像 docker pull redis （2）创建容器 docker run -di –name&#x3D;myredis -p 6379:6379 redis 创建 redis 容器 （3）通过客户端工具连接测试。或者通过java代码用Jedis客户端进行测试。 二、 迁移与备份 其中涉及到的命令有： docker commit 将容器保存为镜像 docker save 将镜像备份为tar文件 docker load 根据tar文件恢复为镜像 2.1 容器保存为镜像我们可以通过以下命令将容器保存为镜像 # 保存nginx容器为镜像 docker commit 容器名称 镜像名称 例如：docker commit mynginx mynginx_i 使用 docker ps -a 查看所有的容器 看到有一个mynginx 容器 , 将容器保存为一个镜像： 查看镜像是否保存成功 使用刚刚保存的镜像 ，重新创建一个容器 创建完成之后 ， 直接 通过 docker ps查看正在运行的容器，可以找到刚刚创建的容器mynginx2 2.2 镜像备份我们可以通过以下命令将镜像保存为tar 文件 # 命令形式：docker save –o tar文件名 镜像名 # 保存镜像为文件 -o：表示output 输出的意思，后跟输出路径+输出保存的文件名 docker save -o mynginx.tar mynginx_i 通过 save 保存成文件之后，在通过 ls 命令进行查看当前目录是否有 tar文件 2.3 镜像恢复与迁移首先我们先删除掉mynginx_img镜像 然后执行此命令进行恢复 # 命令形式：docker load -i tar文件名 docker load -i mynginx.tar -i 表示input输入的文件 执行后再次查看镜像，可以看到镜像已经恢复 我们需要直接恢复刚刚的 tar 文件 ，就需要先删除 mynginx_i 镜像，才能恢复, 直接删除 mynginx_i 镜像 ，发现会报错，因为当前镜像的容器正在运行，需要先停止容器，删除容器 ， 在删除镜像 删除完成之后 ， 在查看镜像是否还存在 ，发现mynginx_i 镜像已经被删除 恢复镜像"},{"title":"08.Docker Compose容器编排","path":"/wiki/docker/08.Docker Compose容器编排.html","content":"一、 Docker-Compose1.1、 什么是Docker ComposeCompose 项目是 Docker 官方的开源项目，负责实现 Docker 容器集群的快速编排，开源代码在 https://github.com/docker/compose 上 我们知道使用 Dockerfile 模板文件可以让用户很方便的定义一个单独的应用容器，其实在工作中，经常会碰到需要多个容器相互配合来完成的某项任务情况，例如工作中的 web 服务容器本身，往往会在后端加上数据库容器，甚至会有负责均衡器，比如 LNMP 服务 Compose 就是来做这个事情的，它允许用户通过一个单独的 docker-compose.yml 模板文件 YAML格式 来定义一组相关联的应用容器为一个项目 project Compose 中有两个重要的概念： 服务 service :一个应用的容器，实际上可以包括若干运行相同镜像的容器实例项目 project :由一组关联的应用容器组成的一个完整业务单元，在docker-compose.yml中定义 1.2、 安装123# docker-compose版本选择:https://github.com/docker/compose/releases# curl -L https://github.com/docker/compose/releases/download/1.25.4/docker-compose-`uname -s`-`uname -m` -o /usr/local/bin/docker-compose# chmod +x /usr/local/bin/docker-compose 1.3、 命令12345678910111213141516171819202122232425262728293031323334353637383940Compose 大部分命令的对象即可以是项目的本身，也可以是指定为项目中的服务或者容器执行docker-compose [COMMAND] --help 或者docker-compose help [COMMAND]可以查看命令的帮助信息具体的使用格式docker-compose [-f=&lt;arg&gt;...] [options] [COMMAND] [ARGS]参数选项-f,--file file指定模板文件，默认是docker-compose.yml模板文件,可以多次指定-p,--project-name name指定项目名称，默认使用所在目录名称作为项目名称--x-networking 使用Docker的后端可插拔网络特性--x-networking-driver driver指定网络的后端驱动，默认使用bridge--verbose 输入更多的调试信息-v,--version 输出版本信息Compose所支持的命令：build 构建项目中的服务容器 bundle 从Compose文件生成分布式应用程序包 config 验证并查看Compose文件 create 为服务创建容器 down 停止容器并删除由其创建的容器，网络，卷和图像up events 为项目中的每个容器流式传输容器事件 exec 这相当于docker exec。 help 获得一个命令的帮助 kill 通过发送SIGKILL信号来强制停止服务容器 logs 查看服务容器的输出 pause 暂停一个容器 port 打印某个容器端口所映射的公共端口 ps 列出项目中目前所有的容器 pull 拉取服务依赖镜像 push 推送服务镜像 restart 重启项目中的服务 rm 删除所有停止状态的服务容器 run 在指定服务上执行一个命令 scale 设置指定服务执行的容器个数 start 启动已存在的服务容器 stop 停止已存在的服务容器 top 显示容器正在运行的进程 unpause 恢复处于暂停状态的容器 up 自动完成包括构建镜像、创建服务、启动服务并关联服务相关容器的一系列操作 version 输出版本 1.4、模板文件排版问题，请看单独的文件。官网链接：https://docs.docker.com/compose/compose-file/#compose-file-structure-and-examples 1.5、 示例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687举个简单的例子来具有的说明一下 Compose 的使用1. 创建一个目录(里面包含需要的文件)[root@zutuanxue] mkdir compose-py2. 创建一个 Python 应用， 使用 Flask ，将数值记入 Redis[root@zutuanxue compose-py] cat app.pyimport time import redisfrom flask import Flask app = Flask(__name__)cache = redis.Redis(host=&#x27;redis&#x27;, port=6379) def get_hit_count(): retries = 5 while True: try: return cache.incr(&#x27;hits&#x27;) except redis.exceptions.ConnectionError as exc: if retries == 0: raise exc retries -= 1 time.sleep(0.5) @app.route(&#x27;/&#x27;)def hello(): count = get_hit_count() return &#x27;Hello World! I have been seen &#123;&#125; times. &#x27;.format(count) if __name__ == &quot;__main__&quot;: app.run(host=&quot;0.0.0.0&quot;, debug=True)3. 创建 requirements.txt 文件，里面是需要安装的 Python 包[root@zutuanxue compose-py] cat requirements.txtflaskredis4. 创建 Dockerfile 文件[root@zutuanxue compose-py] cat DockerfileFROM pythonADD . /codeWORKDIR /codeRUN pip install -r requirements.txtCMD [&quot;python&quot;, &quot;app.py&quot;] # 这告诉Docker： 从 Python 开始构建镜像 将当前目录 . 添加到 /code 镜像中的路径 将工作目录设置为 /code 安装 Python 依赖项 将容器的默认命令设置为 python app.py 5. 创建 docker-compose.yml 文件[root@zutuanxue compose-py] cat docker-compose.ymlversion: &#x27;3&#x27;services: web: build: . ports: - &quot;5000:5000&quot; volumes: - .:/code redis: image: &quot;redis&quot; 此 Compose 文件定义了两个服务，web 和 redis 该web服务：\t使用从 Dockerfile 当前目录中构建的镜像\t将容器上的公开端口 5000 转发到主机上的端口 5000 我们使用 Flask Web 服务器的默认端口 5000\t该 redis 服务使用从 Docker Hub 中提取的公共 Redis 映像\t6. 使用 Compose 构建并运行您的应用程序[root@zutuanxue compose-py] docker-compose up7. 测试访问，在浏览器访问 IP:5000 每刷新一次就会加一"},{"title":"私有仓库registry","path":"/wiki/docker/Docker镜像私有仓库.html","content":"在Docker中，当我们执行 docker pull xxx 的时候 ，它实际上是从 hub.docker.com 这个地址去查找，这就是 Docker 公司为我们提供的公共仓库。在工作中，我们不可能把企业项目 push 到公有仓库进行管理。所以为了更好的管理镜像，Docker 不仅提供了一个中央仓库，同时也允许我们搭建本地私有仓库。 docker容器镜像仓库分类： 公网仓库：docker hub 私网仓库: registry、harbor 一、registry镜像仓库1.1、 registry 仓库搭建搭建步骤 拉取 registry 容器镜像 创建 registry 仓库容器 测试容器应用 搭建过程a、拉取registry容器镜像 1docker pull registry b、创建registry仓库容器 12345678910111213141、创建持久化存储，将容器镜像存储目录/var/lib/registry挂载到本地/opt/myregistry下：mkdir /opt/myregistry2、创建 registry 容器：docker run -d -p 5000:5000 -v /opt/myregistry:/var/lib/registry --restart=always registry:latest3、查看容器是否运行docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES6b20b55fe6f8 registry:latest &quot;/entrypoint.sh /etc…&quot; 2 minutes ago Up 2 minutes 0.0.0.0:5000-&gt;5000/tcp busy_mclean c、测试容器应用 1234[root@zutuanxue_manage01 ~]# curl http://192.168.1.150:5000/v2/_catalog&#123;&quot;repositories&quot;:[]&#125;显示仓库中没有任何镜像 1.2、registry仓库应用-上传镜像上传镜像步骤 设置docker仓库为registry本地仓库 给需要存储的镜像打tag 上传镜像到registry仓库 演示案例 将baishuming2020&#x2F;centos_nginx:latest上传到仓库 查看当前本地镜像 123456[root@zutuanxue_manage01 ~]# docker imagesREPOSITORY TAG IMAGE ID CREATED SIZEbaishuming2020/centos_nginx latest bcd9f28f6126 33 minutes ago 447MBbaishuming2020/centos_8_base latest 3e9f682f8459 47 minutes ago 200MBcentos latest 0f3e07c0138f 6 weeks ago 220MBregistry latest f32a97de94e1 8 months ago 25.8MB a、设置docker仓库为registry本地仓库 1234567891011121314#1、修改docker进程启动文件，修改其启动方式，目的是为了让通过docker配置文件启动[root@zutuanxue_manage01 ~]# sed -i.bak &#x27;/^ExecStart=/c\\ExecStart=\\/usr\\/bin\\/dockerd&#x27; /usr/lib/systemd/system/docker.service#2、设置docker 守护进程的配置文件 /etc/docker/daemon.json,默认没有该文件[root@zutuanxue_manage01 ~]# cat /etc/docker/daemon.json &#123; &quot;insecure-registries&quot;: [&quot;http://192.168.1.150:5000&quot;]&#125;insecure-registries 指定非安全的仓库地址，多个用逗号隔开#3、重启docker生效配置文件[root@zutuanxue_manage01 ~]# systemctl daemon-reload[root@zutuanxue_manage01 ~]# systemctl restart docker b、给需要存储的镜像打tag 123456789[root@zutuanxue_manage01 ~]# docker tag baishuming2020/centos_nginx:latest 192.168.1.150:5000/centos_nginx:v1[root@zutuanxue_manage01 ~]# docker imagesREPOSITORY TAG IMAGE ID CREATED SIZE192.168.98.240:5000/centos_nginx v1 bcd9f28f6126 45 minutes ago 447MBbaishuming2020/centos_nginx latest bcd9f28f6126 45 minutes ago 447MBbaishuming2020/centos_8_base latest 3e9f682f8459 59 minutes ago 200MBcentos latest 0f3e07c0138f 6 weeks ago 220MBregistry latest f32a97de94e1 8 months ago 25.8MB c、上传镜像到registry仓库 1234567891011121314151617181920#1、上传镜像[root@zutuanxue_manage01 ~]# docker push 192.168.98.240:5000/centos_nginx:v1The push refers to repository [192.168.98.240:5000/centos_nginx]1da799aaf1ec: Pushed f598357997c6: Pushed 630012d2d35b: Pushed 4dcde7ab808a: Pushed 64dc1b92ebb6: Pushed 7db2133dafb9: Pushed fd05189e6e81: Pushed ee645629aa71: Pushed v1: digest: sha256:507a5ad9dd5771cdf461a6fa24c3fff6ea9eabd6945abf03e9264d3130fe816b size: 1996#2、查看上传[root@zutuanxue_manage01 ~]# curl http://192.168.98.240:5000/v2/_catalog&#123;&quot;repositories&quot;:[&quot;centos_nginx&quot;]&#125;#查看存储文件夹[root@zutuanxue_manage01 ~]# ls /opt/docker_repos/docker/registry/v2/repositories/centos_nginx/_layers _manifests _uploads 1.3、 registry仓库应用-客户端下载镜像 设置客户端docker仓库为registry仓库 拉取镜像到本地 演示案例 要求192.168.98.241[hostname:zutuanxue_node1]机器的容器可以下载registry仓库中的镜像 a、设置192.168.1.151[hostname:zutuanxue_node1]机器的docker仓库为registry仓库 12345678#1、设置docker启动文件[root@zutuanxue_node1 ~]# sed -i.bak &#x27;/^ExecStart=/c\\ExecStart=\\/usr\\/bin\\/dockerd&#x27; /usr/lib/systemd/system/docker.service#2、设置docker配置文件[root@zutuanxue_node1 ~]# cat /etc/docker/daemon.json &#123; &quot;insecure-registries&quot;: [&quot;http://192.168.1.150:5000&quot;]&#125; b、下载镜像192.168.1.151[hostname:zutuanxue_node1]机器上的docker可以拉取registry仓库中的192.168.1.150:5000&#x2F;centos_nginx:v1容器镜像 123456789101112131415161718[root@zutuanxue_node1 ~]# docker pull 192.168.1.150:5000/centos_nginx:v1v1: Pulling from centos_nginxdcd04d454f16: Pull complete 5cb2e05aa6e1: Pull complete 870634eb98b4: Pull complete 0fae9697ee4b: Pull complete 18ad57cfcecb: Pull complete 64dd6f0d85c1: Pull complete 7178b0b4388e: Pull complete 34de8795cd41: Pull complete Digest: sha256:507a5ad9dd5771cdf461a6fa24c3fff6ea9eabd6945abf03e9264d3130fe816bStatus: Downloaded newer image for 192.168.98.240:5000/centos_nginx:v1192.168.98.240:5000/centos_nginx:v1#验证下载[root@zutuanxue_node1 ~]# docker imagesREPOSITORY TAG IMAGE ID CREATED SIZE192.168.1.150:5000/centos_nginx v1 bcd9f28f6126 4 hours ago 447MB 1.4、registry带basic认证的仓库实现步骤 安装需要认证的包 创建存放认证信息的文件 创建认证信息 创建带认证的registry容器 指定仓库地址 登录认证 实现过程a、安装需要认证的包 1yum -y install httpd-tools b、创建存放认证信息的文件 1mkdir -p /opt/registry-var/auth c、创建认证信息 1htpasswd -Bbn zutuanxue 123456 &gt;&gt; /opt/registry-var/auth/htpasswd d、创建带认证的registry容器 1234567docker run -d -p 10000:5000 --restart=always --name registry \\-v /opt/registry-var/auth:/auth \\-v /opt/myregistry:/var/lib/registry \\-e &quot;REGISTRY_AUTH=htpasswd&quot; \\-e &quot;REGISTRY_AUTH_HTPASSWD_REALM=Registry Realm&quot; \\-e REGISTRY_AUTH_HTPASSWD_PATH=/auth/htpasswd \\registry:latest e、指定仓库地址 1234cat /etc/docker/daemon.json &#123; &quot;insecure-registries&quot;: [&quot;http://192.168.1.150:5000&quot;,&quot;http://192.168.1.150:10000&quot;]&#125; f、登录认证 123docker login 192.168.1.150:10000Username：zutuanxuePassword：123456 二、 harbor镜像仓库Harbor离线安装包下载地址：https://github.com/goharbor/harbor docker-compose版本选择:https://github.com/docker/compose/releases 2.1 harbor下载1[root@centos8_manage01 ~]# wget https://storage.googleapis.com/harbor-releases/release-1.9.0/harbor-offline-installer-v1.9.2-rc1.tgz 2.2 docker-compose安装容器编排工具，执行.&#x2F;install.sh时需要。如果不安装，一会重启docker服务，相关的harbor容器会死掉，安装后就会被随着docker重启 12curl -L https://github.com/docker/compose/releases/download/1.25.4/docker-compose-`uname -s`-`uname -m` -o /usr/local/bin/docker-composechmod +x /usr/local/bin/docker-compose 2.3 harbor安装123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183[root@centos8_manage01 ~]# tar xf harbor-offline-installer-v1.9.2-rc1.tgz [root@centos8_manage01 ~]# mv harbor /opt/[root@centos8_manage01 ~]# /opt/harbor/prepare prepare base dir is set to /opt/harborUnable to find image &#x27;goharbor/prepare:v1.9.2&#x27; locallyv1.9.2: Pulling from goharbor/prepareb950b5dd94ab: Pull complete cc7bb94ca291: Pull complete d6a642502e65: Pull complete 21510274066b: Pull complete 04998692a2c0: Pull complete ae8f4647fe53: Pull complete cee24c721c12: Pull complete Digest: sha256:a647780bcd7f5fdcc9696332c9bca90f290912ecb41bd15c4c1a516450597bc2Status: Downloaded newer image for goharbor/prepare:v1.9.2Generated configuration file: /config/log/logrotate.confGenerated configuration file: /config/log/rsyslog_docker.confGenerated configuration file: /config/nginx/nginx.confGenerated configuration file: /config/core/envGenerated configuration file: /config/core/app.confGenerated configuration file: /config/registry/config.ymlGenerated configuration file: /config/registryctl/envGenerated configuration file: /config/db/envGenerated configuration file: /config/jobservice/envGenerated configuration file: /config/jobservice/config.ymlGenerated and saved secret to file: /secret/keys/secretkeyGenerated certificate, key file: /secret/core/private_key.pem, cert file: /secret/registry/root.crtGenerated configuration file: /compose_location/docker-compose.ymlClean up the input dir修改配置文件中的主机名为本机域名或IP[root@centos8_manage01 ~]# grep &quot;^hostname&quot; /opt/harbor/harbor.yml hostname: 192.168.98.240[root@centos8_manage01 ~]# /opt/harbor/install.sh [Step 0]: checking installation environment ...Note: docker version: 19.03.1/usr/lib/python2.7/site-packages/requests/__init__.py:91: RequestsDependencyWarning: urllib3 (1.24.3) or chardet (2.2.1) doesn&#x27;t match a supported version! RequestsDependencyWarning)Note: docker-compose version: 1.24.1[Step 1]: loading Harbor images ...6ef530defbe4: Loading layer 63.49MB/63.49MB55872518448e: Loading layer 54.42MB/54.42MB070787ce276e: Loading layer 5.632kB/5.632kB1ddc8ebef7e9: Loading layer 2.048kB/2.048kB94ec70036213: Loading layer 2.56kB/2.56kB87f88832870d: Loading layer 2.56kB/2.56kB208968317bf9: Loading layer 2.56kB/2.56kBab6259c81a01: Loading layer 10.24kB/10.24kBLoaded image: goharbor/harbor-db:v1.9.292e51ca4c459: Loading layer 9.005MB/9.005MB9e12eb4a5a82: Loading layer 3.072kB/3.072kB913c064dae30: Loading layer 21.76MB/21.76MBb28cae8255d8: Loading layer 3.072kB/3.072kB890572f32fd2: Loading layer 8.661MB/8.661MB6f00be7ade9a: Loading layer 30.42MB/30.42MBLoaded image: goharbor/harbor-registryctl:v1.9.251bada9a03ba: Loading layer 78.25MB/78.25MBbdd423614a28: Loading layer 3.072kB/3.072kBe44c809a7328: Loading layer 59.9kB/59.9kB07d91c85aa68: Loading layer 61.95kB/61.95kBLoaded image: goharbor/redis-photon:v1.9.2e0a372c4d5d3: Loading layer 10.84MB/10.84MBLoaded image: goharbor/nginx-photon:v1.9.299f324455426: Loading layer 115.7MB/115.7MBdbde533bd1f2: Loading layer 12.29MB/12.29MB32adabde1b24: Loading layer 2.048kB/2.048kBcdedbb7b738d: Loading layer 48.13kB/48.13kB60eb6ca8f5f9: Loading layer 3.072kB/3.072kB05fadada21a7: Loading layer 12.34MB/12.34MBLoaded image: goharbor/clair-photon:v2.0.9-v1.9.2fbe05936a49e: Loading layer 12.77MB/12.77MB8dc691e9365f: Loading layer 55.38MB/55.38MBc83233ecc176: Loading layer 5.632kB/5.632kBde775c6f50f5: Loading layer 36.35kB/36.35kB525709237f01: Loading layer 55.38MB/55.38MBLoaded image: goharbor/harbor-core:v1.9.2734abd864add: Loading layer 12.77MB/12.77MB74033d37bf08: Loading layer 48.13MB/48.13MBLoaded image: goharbor/harbor-jobservice:v1.9.26677f529d41e: Loading layer 9.005MB/9.005MB019a95ff5e80: Loading layer 3.072kB/3.072kB4b3792cedc69: Loading layer 2.56kB/2.56kB274f5851694b: Loading layer 21.76MB/21.76MB68e937b2af9e: Loading layer 21.76MB/21.76MBLoaded image: goharbor/registry-photon:v2.7.1-patch-2819-2553-v1.9.2Loaded image: goharbor/prepare:v1.9.20566b1894f2e: Loading layer 9.009MB/9.009MBb99c86e48679: Loading layer 44.41MB/44.41MB283ba1db5c52: Loading layer 2.048kB/2.048kB701de676a8f6: Loading layer 3.072kB/3.072kBc923d0b0255c: Loading layer 44.41MB/44.41MBLoaded image: goharbor/chartmuseum-photon:v0.9.0-v1.9.2ef4a961407c7: Loading layer 9.004MB/9.004MB7cf94e5011b7: Loading layer 6.239MB/6.239MB5c984b34ecb2: Loading layer 16.4MB/16.4MBf06fb877e324: Loading layer 29.21MB/29.21MBae07ec384ebd: Loading layer 22.02kB/22.02kB864698f2b94d: Loading layer 51.85MB/51.85MBLoaded image: goharbor/notary-server-photon:v0.6.1-v1.9.2c953b6400a8b: Loading layer 50.3MB/50.3MB2ee784d17d84: Loading layer 3.584kB/3.584kBc71f6b26fd01: Loading layer 3.072kB/3.072kBbb6389098841: Loading layer 2.56kB/2.56kBb63da553de9f: Loading layer 3.072kB/3.072kB62a479d14974: Loading layer 3.584kB/3.584kBaa3fee5917b8: Loading layer 12.29kB/12.29kBLoaded image: goharbor/harbor-log:v1.9.2691af8d2c981: Loading layer 14.9MB/14.9MB7878347ee491: Loading layer 29.21MB/29.21MB433f16e7c539: Loading layer 22.02kB/22.02kBad0202306aed: Loading layer 50.34MB/50.34MBLoaded image: goharbor/notary-signer-photon:v0.6.1-v1.9.262247cb7cb19: Loading layer 337.8MB/337.8MBd8b748aaf7dd: Loading layer 119.8kB/119.8kBLoaded image: goharbor/harbor-migrator:v1.9.2d9705202f79f: Loading layer 7.036MB/7.036MB3fdb77b47894: Loading layer 196.6kB/196.6kB8901bb1db41e: Loading layer 172kB/172kBbaf9307d1844: Loading layer 15.36kB/15.36kB1dcfba9b1bd1: Loading layer 3.584kB/3.584kB90a90fef2f80: Loading layer 10.84MB/10.84MBLoaded image: goharbor/harbor-portal:v1.9.2[Step 2]: preparing environment ...prepare base dir is set to /opt/harborClearing the configuration file: /config/log/logrotate.confClearing the configuration file: /config/log/rsyslog_docker.confClearing the configuration file: /config/nginx/nginx.confClearing the configuration file: /config/core/envClearing the configuration file: /config/core/app.confClearing the configuration file: /config/registry/config.ymlClearing the configuration file: /config/registryctl/envClearing the configuration file: /config/registryctl/config.ymlClearing the configuration file: /config/db/envClearing the configuration file: /config/jobservice/envClearing the configuration file: /config/jobservice/config.ymlGenerated configuration file: /config/log/logrotate.confGenerated configuration file: /config/log/rsyslog_docker.confGenerated configuration file: /config/nginx/nginx.confGenerated configuration file: /config/core/envGenerated configuration file: /config/core/app.confGenerated configuration file: /config/registry/config.ymlGenerated configuration file: /config/registryctl/envGenerated configuration file: /config/db/envGenerated configuration file: /config/jobservice/envGenerated configuration file: /config/jobservice/config.ymlloaded secret from file: /secret/keys/secretkeyGenerated configuration file: /compose_location/docker-compose.ymlClean up the input dir/usr/lib/python2.7/site-packages/requests/__init__.py:91: RequestsDependencyWarning: urllib3 (1.24.3) or chardet (2.2.1) doesn&#x27;t match a supported version! RequestsDependencyWarning)[Step 3]: starting Harbor .../usr/lib/python2.7/site-packages/requests/__init__.py:91: RequestsDependencyWarning: urllib3 (1.24.3) or chardet (2.2.1) doesn&#x27;t match a supported version! RequestsDependencyWarning)Creating network &quot;harbor_harbor&quot; with the default driverCreating harbor-log ... doneCreating harbor-portal ... doneCreating redis ... doneCreating registryctl ... doneCreating registry ... doneCreating harbor-db ... doneCreating harbor-core ... doneCreating nginx ... doneCreating harbor-jobservice ... done✔ ----Harbor has been installed and started successfully.----Now you should be able to visit the admin portal at http://192.168.98.240. For more details, please visit https://github.com/goharbor/harbor . 2.4 docker设置仓库为harbor123456789101、docker服务启动文件#ExecStart=/usr/bin/dockerd -H fd:// --containerd=/run/containerd/containerd.sock 注释或者将[-H fd:// --containerd=/run/containerd/containerd.sock]删除ExecStart=/usr/bin/dockerd 这样做的目的是让daemon.json管理docker进程2、创建docker守护进程配置文件[root@centos8_manage01 harbor]# cat /etc/docker/daemon.json &#123; &quot;insecure-registries&quot;: [&quot;http://192.168.98.240&quot;]&#125; 2.5 镜像上传到harbor123456789101112131415161718#登陆harbor[root@centos8_manage01 harbor]# docker login http://192.168.98.240 -u admin -p Harbor12345WARNING! Using --password via the CLI is insecure. Use --password-stdin.WARNING! Your password will be stored unencrypted in /root/.docker/config.json.Configure a credential helper to remove this warning. Seehttps://docs.docker.com/engine/reference/commandline/login/#credentials-storeLogin Succeeded#修改镜像name:tag为harbor仓库名[root@centos8_manage01 harbor]# docker tag baishuming2020:latest 192.168.98.240/library/centos_web:v1#上传镜像[root@centos8_manage01 harbor]# docker push 192.168.98.240/library/centos_web:v1The push refers to repository [192.168.98.240/library/centos_web]968786242e9d: Pushed v1: digest: sha256:d204253a33c6c2c74273fbd003cf3e14a48bcdd5c7bc10f51ccbad9e4dd39699 size: 528 常见问题docker-compose命令无法使用[root@centos8_manage01 ~]# docker-compose psERROR:Can’t find a suitable configuration file in this directory or anyparent. Are you in the right directory? 1Supported filenames: docker-compose.yml, docker-compose.yaml 原因： 当前目录没有配置文件 12345678910111213正确执行路径 harbor安装目录[root@centos8_manage01 harbor]# docker-compose ps Name Command State Ports -----------------------------------------------------------------------------------------harbor-core /harbor/harbor_core Up harbor-db /docker-entrypoint.sh Up 5432/tcp harbor-jobservice /harbor/harbor_jobservice ... Up harbor-log /bin/sh -c /usr/local/bin/ ... Up 127.0.0.1:1514-&gt;10514/tcpharbor-portal nginx -g daemon off; Up 8080/tcp nginx nginx -g daemon off; Up 0.0.0.0:80-&gt;8080/tcp redis redis-server /etc/redis.conf Up 6379/tcp registry /entrypoint.sh /etc/regist ... Up 5000/tcp registryctl /harbor/start.sh Exit 137 三、企业级仓库：Harbor（推荐） Harbor 是一个用于存储和分发 Docker 镜像的企业级 Registry 服务器。 扩展了开源 Docker Distribution。作为一个企业级私有 Registry 服务器，Harbor 提供了更好的性能和安全 支持镜像扫描：恶意程序，bug等。 硬件配置根据具体需求而定，官方文档 node节点都需要配置信任关系，否则上传不了镜像 1. 实验准备 获取安装程序：确认版本前往github源码下载源码安装包。 安装docker docker-compose依赖：docker version 16.7以上。 1.上github找到[docker](https://github.com/docker)/**[compose](https://github.com/docker/compose)**项目。下载[docker-compose](https://github.com/docker/compose/releases) 2.解压cp/usr/bin/目录下并改名： &#123;% u cp docker-compose-linux-x86_64 /usr/bin/docker-compose %&#125; #a+x权限 3.执行docker-compose version ，是否显示版本号。 更改barbor配置文件 tar -xvf harbor-offline-installer-v2.6.1.tgz cp harbor.yml.tmpl harbor.yml vim harbor.yml hostname: harbor.子域名.com #可以是域名&#x2F;ip&#x2F;主机名 harbor_admin_password: 12345 #密码 password: root123 #数据库容器密码 data_volume: &#x2F;data&#x2F;harbordata# 数据挂载点 2. 部署安装1.安装 [root@harbor harbor]# .&#x2F;install.sh #做好准备工作执行安装脚本 安装完成，更改hosts解析，访问 harbor.子域名.com确认结果 账户默认admin 密码自己前面配置指定 2.逻辑 3. 开启扫描器（最好事先开启） trivy：hithub项目地址 安装前：.&#x2F;install.sh –with-clair 新版本：.&#x2F;install.sh –with-trivy 安装后：.&#x2F;prepare –with-clair 新版本：.&#x2F;prepare –with-trivy 4. 客户端使用4.1.添加本地信任添加信任关系，修改docker.servicer文件：–insecure-registry harbor.域名.com&#x2F;ip：端口 4.2.上传下载 解析——配置docker文件——登录到私有仓库 在仓库先创建好项目名称 systemctl daemon-reload systemctl restart docker 登录到仓库：docker login harbor.域名.com 修改镜像tag： docker tag registry.cn-shanghai.aliyuncs.com&#x2F;czsmall&#x2F;mes:1.1 harbor.boloni.com&#x2F;mes&#x2F;nginx:1.1 上传下载 5. harbor容器介绍 nginx：harbor 的一个反向代理组件，代理 registry、ui、token 等服务。这个代 理会转发 harbor web 和 docker client 的各种请求到后端服务上。 harbor-adminserver：harbor 系统管理接口，可以修改系统配置以及获取系统信 息。 harbor-db：存储项目的元数据、用户、规则、复制策略等信息。 harbor-jobservice：harbor 里面主要是为了镜像仓库之前同步使用的。 harbor-log：收集其他 harbor 的日志信息。 harbor-ui：一个用户界面模块，用来管理 registry。 registry：存储 docker images 的服务，并且提供 pull&#x2F;push 服务。 redis：存储缓存信息 webhook：当 registry 中的 image 状态发生变化的时候去记录更新日志、复制 等操作。 token service：在 docker client 进行 pull&#x2F;push 的时候负责 token 的发放。 6. 企业级仓库：Harbor高可用 基于共享存储： 基于内部docker复制功能：类似于 MySQL 的主从同步， 其可以实现不同的数据中心、不同的运行环境之间同步镜像，并提供友好的管理 界面，大大简化了实际运维中的镜像管理工作 仓库同步+HAproxy实现 一：仓库管理#两边都需要配置 目标名;对方的仓库名称，目标url：对方的地址：http….访问i账号，密码 二：同步管理#两边都需要配置 在主服务器端配置：两边项目名称必须一致，同步模式选push-based，触发模式：事件 四、 阿里 公司的容器千万不要上传到共有仓库 官方仓库：目前有阿里与hub.Docker。因Docker官方仓库在国外，访问不稳定。不做重点使用。 私有仓库： 创建镜像时。共有仓库上传需要认证，而下载不需要。私有仓库无论上传下载都需要认证。 docker官方仓库不需要指定URL，直接docker login登录 信任仓库如果仅仅是下载镜像就不需要登录即可下载(在dockerd的service文件添加–insecure-registry 172.31.6.102:80) 1. 登录阿里云Docker Registry1，登录阿里容器镜像服务,找到实列列表——个人实例&#x2F;企业版——镜像仓库 2，创建仓库。命令空间可以理解为一个tag。仓库名称可以理解为什么同一个项目的名称。 3，回到作者的电脑，登录自己的镜像仓库：docker login 回车密码后，提示Login Succeeded才算成功 $ docker login –username&#x3D;账号@163.com registry.cn-shanghai.aliyuncs.com$ Password: 2. 将镜像推送到aliyun Registryborder 修改tag格式-上传$ docker tag [本地镜像:版本号] registry.cn-shanghai.aliyuncs.com&#x2F;czsmall&#x2F;mes:[镜像版本号] $ docker push registry.cn-shanghai.aliyuncs.com&#x2F;czsmall&#x2F;mes:[镜像版本号] 3. 从Registry中拉取镜像$ docker pull registry.cn-shanghai.aliyuncs.com&#x2F;czsmall&#x2F;mes:[镜像版本号] 五、 官方仓库：docker1.登录hub.Docker Registry1.登录(Docker Hub,创建仓库。 2.回到作者电脑，登录自己的镜像仓库：docker login 回车密码后，提示Login Succeeded才算成功 $ docker login docke Username: czsmall Password: 2. 将镜像推送到aliyun Registry 首先修改本地需要上传的images，tag。格式：仓库名字或者项目名/镜像images名：tag 上传时可不写域名，默认为什么hub.docker。 docker tag harvey&#x2F;nginx:1.3 docker.io&#x2F;czsmall&#x2F;nginx:1.1 #给镜像打tag docker push docker.io&#x2F;czsmall&#x2F;nginx:1.1 #上传镜像 3,从Registry中拉取镜像docker pull czsmall&#x2F;nginx:1.1 #下载镜像到本地 查看认证信息。 #登录成功之后会在当前目录生成一个隐藏文件用于保存登录认证信息 [root@k-node2 ~]# cat &#x2F;root&#x2F;.docker&#x2F;config.json{ “auths”: { “https://index.docker.io/v1/“: { “auth”: “Y3pzbp6aGFoMDgwNzE1MTU&#x3D;” }, “registry.cn-shanghai.aliyuncs.com”: { “auth”: “aGNvbmNvbTp6aGFoMDgwNw&#x3D;&#x3D;” } }"}]