[{"title":"测试文章","path":"/2023/09/14/测试页/","content":"在心率管家默默无闻地上线了一年多之后，现在终于打算来好好聊聊关于手机摄像头测量心率的那些事。本文参考了很多前辈的文章，将在文末列出。 后面是正文部分，在主页看不到。 h1 &#x2F;bibi&#x2F;poster: topic: #标题上方的小字 # 可选 headline: 测试文章页 caption: 下方的小标题 # color: 标题颜色 # 可选，默认为跟随主题的动态颜色 # white,red…tags: [测试] #标签categories: #分类相关文章推荐要实现相关文章推荐功能，您需要安装插件： npm i hexo-related-popular-posts然后在主题配置文件中开启： blog&#x2F;_config.stellar.ymlarticle: npm i hexo-related-popular-posts related_posts: enable: true title: 您可能感兴趣的文章Copy开启后会在每篇文章的下方推荐相同类型的文章。 参考资料填写引用文章的标题和链接： references: - title: ‘心跳之旅—💗—iOS用手机摄像头检测心率(PPG)’ url: https://punmy.cn/2016/07/28/15231176397746.html - title: ‘PPG光电容积脉搏波描记法技术概况’ url: https://www.jianshu.com/p/695c131abfa5 …[https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimg.nga.178.com%2Fattachments%2Fmon_202011%2F28%2F7nQ5-bx27XlZ5yT3cS1h8-tz.png&refer=http%3A%2F%2Fimg.nga.178.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=auto?sec=1697445446&t=cb5250208a77c702c701da03ced37ec4] [download:bool/string] Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start cover: &#x2F;assets&#x2F;xaoxuu&#x2F;blog&#x2F;&#50;&#x30;&#50;&#48;&#x2d;&#48;&#57;&#50;&#55;&#x61;&#64;&#x31;&#120;&#x2e;&#x73;&#x76;&#x67; # 必选poster: # 海报（可选，全图封面卡片） topic: 标题上方的小字 # 可选 headline: 大标题 # 必选 caption: 标题下方的小字 # 可选 color: 标题颜色 # 可选，默认为跟随主题的动态颜色 # white,red… –topic 时大标题位于上方caption 时大标题位于下方 [描述] [download:bool/string] f 支持多彩标记，包括：默认 红 橙 黄 绿 青 蓝 紫 浅 深 警告 错误 一共 12 种颜色。mark 行内文本标记 支持多彩标记，包括： 默认 红 橙 黄 绿 青 蓝 紫 浅 深 警告 错误 一共 12 种颜色。 tag 标签 Stellar Hexo GitHub Gitea image 图片标签 [description] [download:true] [width:px] [padding:px] [bg:hex] src: 图片地址description: 图片描述download: href # 下载地址，设置此值后鼠标放在图片上会显示下载地址，如果下载地址为图片地址，可以设置为 truewidth: 200px # 图片宽度padding: 16px # 图片四周填充宽度bg: ‘#ffffff’ # 图片区域背景颜色，16进制 来自印度的 Rohit Vohra 使用 iPhone 12 Pro Max 拍摄。 没有底色的图片，可以填充 bg:var(–card) 动态颜色，能够适配暗黑模式： 适合居中且醒目的引用：Stellar 是最好用的主题支持自定义引号：热门话题 此外，加上 el:h2&#x2F;h3&#x2F;h4&#x2F;h5&#x2F;h6 可以作为标题使用 poetry 诗词 游山西村陆游莫笑农家腊酒浑，丰年留客足鸡豚。山重水复疑无路，柳暗花明又一村。箫鼓追随春社近，衣冠简朴古风存。从今若许闲乘月，拄杖无时夜叩门。诗词节选 title: 标题（可选）content: 内容color: red&#x2F;orange&#x2F;yellow&#x2F;green&#x2F;cyan&#x2F;blue&#x2F;purple&#x2F;light&#x2F;dark&#x2F;warning&#x2F;error 具有标题的备注块直接写备注内容，默认是和代码块一样的样式，第一个空格前面的是标题，后面的是正文，如果标题中需要显示空格，请使用 &nbsp; 代替。 这&nbsp;是/可用空格代替标题标题这是正文 哈哈。 彩色备注块 一共支持12种颜色，可以满足几乎所有的需求了。color 可设置 red、orange、yellow、green、cyan、blue、purple、light、dark、warning、error 几种取值。 一共支持12种颜色，可以满足几乎所有的需求了。color 可设置 red、orange、yellow、green、cyan、blue、purple、light、dark、warning、error 几种取值。 link 链接卡片 #% link href [title] [icon:src] [desc:true&#x2F;false] %# 不带摘要的样式： https://xaoxuu.com/blog/20221029/https://xaoxuu.com/blog/20221029/ 带摘要的样式： https://xaoxuu.com/blog/20221029/https://xaoxuu.com/blog/20221029/ href: 链接title: 可选，手动设置标题（为空时会自动抓取页面标题）icon: 可选，手动设置图标（为空时会自动抓取页面图标）desc: 可选，是否显示摘要描述，为true时将会显示页面描述 copy 复制行 没有勾选的单选框 已勾选的单选框 参数：checked: true&#x2F;falsecolor: red&#x2F;orange&#x2F;yellow&#x2F;green&#x2F;cyan&#x2F;blue&#x2F;purple checkbox 复选 普通的没有勾选的复选框 普通的已勾选的复选框 显示为加号的绿色的已勾选的复选框 显示为减号的黄色的已勾选的复选框 显示为乘号的红色的已勾选的复选框 checked: true&#x2F;falsecolor: red&#x2F;orange&#x2F;yellow&#x2F;green&#x2F;cyan&#x2F;blue&#x2F;purplesymbol: plus&#x2F;minus&#x2F;times 内置当行 文章项目留言GitHub 设备 这是 密码 标签 这是 下划线 标签 这是 着重号 标签 这是 波浪线 标签 这是 删除线 标签 这是 上角标 标签 这是 下角标 标签 这是 键盘样式 标签，试一试：⌘ + D 静态时间线：静态数据是写死在 md 源文件中的，在 deploy 时就已经确定了。 2021 年 2 月 16 日主要部分功能已经开发的差不多了。2021 年 2 月 11 日今天除夕，也是生日，一个人在外地过年+过生日，熬夜开发新主题，尽量在假期结束前放出公测版。 原密码 第一步：打开 GitHub打开 Stellar 的 GitHub 页面。第二步：点击 Star如果发现右上角的 Star 还没点亮，就点亮它！ 近期动态（说说） 动态数据是从 GitHub Issues 中拉取的，使用方法为： 建一个仓库创建一个 issue 并添加一个 label 进行测试写 timeline 标签时加上 api:https://api.github.com/repos/your-name/your-repo/issues 设置 user:xxx 则会只显示某人发的 issue 数据，可以用来展示个人动态。 友链文章订阅 嗯，除了 issues 和 releases 数据，时间线还兼容「友链朋友圈」数据，可以展示小伙伴们最近发布的文章： 侧边栏时间线 在 source&#x2F;_data&#x2F;widgets.yml 文件中创建时间线组件：timeline: layout: timeline title: 近期动态 api: https://api.github.com/repos/xaoxuu/blog-timeline/issues?per_page=1 user: xaoxuu timeline_stellar_more: layout: timeline title: Stellar 探索号 api: https://api.github.com/repos/xaoxuu/hexo-theme-stellar/issues?state=all&amp;labels=分享&amp;per_page=5 hide: title 然后在需要显示的页面的 front-matter 中的 sidebar 部分写上它的名字，例如本文的配置： sidebar: [toc, timeline_stellar_more] 您可以在任何位置插入友链组，支持静态数据和动态数据，静态数据需要写在数据文件中： friends 友链 blog&#x2F;source&#x2F;_data&#x2F;links.yml‘开源大佬’: - title: 某某某 url: https:&#x2F;&#x2F; screenshot: avatar: description: sites 网站卡片 您可以在任何位置插入网站卡片组，支持静态数据和动态数据，静态数据需要写在数据文件中：blog&#x2F;source&#x2F;_data&#x2F;links.yml‘分组名’: title: 某某某url: https:&#x2F;&#x2F;screenshot:avatar:description: 在需要的位置这样写： 容器类标签（7个） 语法格式 [title] [color:color] [child:codeblock/tabs]… Stellar v1.12.0因为原 noteblock 标签在升级到 hexo 6.0 之后跟官方库冲突了，官方一直没有解释原因，后不得不改名：noteblock -&gt; grid -&gt; border详情见：#172 1sdfs &lt;center&gt; &lt;/br&gt; &lt;script type=&quot;text/javascript&quot;&gt; function show_runtime() &#123; window.setTimeout(&quot;show_runtime()&quot;, 1000); X = new Date(&quot;9/15/2023 00:00:00&quot;); Y = new Date(); T = (Y.getTime() - X.getTime()); M = 24 * 60 * 60 * 1000; a = T / M; A = Math.floor(a); b = (a - A) * 24; B = Math.floor(b); c = (b - B) * 60; C = Math.floor((b - B) * 60); D = Math.floor((c - C) * 60); runtime_span.innerHTML = &quot;⏱️本站已艰难运行 &quot; + A + &quot;天&quot; + B + &quot;小时&quot; + C + &quot;分&quot; + D + &quot;秒&quot; &#125; show_runtime(); &lt;/script&gt; &lt;span id=&quot;runtime_span&quot;&gt;&lt;/span&gt; &lt;/center&gt; &lt;center&gt; &lt;/br&gt; &lt;script type=&quot;text/javascript&quot;&gt; function show_runtime() &#123; window.setTimeout(&quot;show_runtime()&quot;, 1000); X = new Date(&quot;9/15/2023 00:00:00&quot;); Y = new Date(); T = (Y.getTime() - X.getTime()); M = 24 * 60 * 60 * 1000; a = T / M; A = Math.floor(a); b = (a - A) * 24; B = Math.floor(b); c = (b - B) * 60; C = Math.floor((b - B) * 60); D = Math.floor((c - C) * 60); runtime_span.innerHTML = &quot;⏱️本站已艰难运行 &quot; + A + &quot;天&quot; + B + &quot;小时&quot; + C + &quot;分&quot; + D + &quot;秒&quot; &#125; show_runtime(); &lt;/script&gt; &lt;span id=&quot;runtime_span&quot;&gt;&lt;/span&gt; &lt;/center&gt; &#123;% tabs active:3 %&#125; &#123;% timeline %&#125; 本地git+server+nginx方式部署调试。 [阿里云](https://wanwang.aliyun.com/)注册域名！ &#123;% endtimeline %&#125; ## 愿望清单 &#123;% grid bg: %&#125; &#123;% image https://images.unsplash.com/photo-1625171515821-1870deb2743b?ixlib=rb-4.0.3&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&fit=crop&w=774&q=80 width:200px %&#125; Unsplash Photo The Galactic Center is the rotational center of the Milky Way galaxy. Its central massive object is a supermassive black hole of about 4 million solar masses, which is called Sagittarius A*. Its mass is equal to four million suns. The center is > located 25,800 light years away from Earth. &#123;% endgrid %&#125; &#123;% swiper effect:cards %&#125; &#123;% image https://images.unsplash.com/photo-1625171515821-1870deb2743b?ixlib=rb-4.0.3&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&fit=crop&w=774&q=80 %&#125; &#123;% image https://images.unsplash.com/photo-1528283648649-33347faa5d9e?ixlib=rb-4.0.3&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&fit=crop&w=774&q=80 %&#125; &#123;% image https://images.unsplash.com/photo-1542272201-b1ca555f8505?ixlib=rb-4.0.3&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&fit=crop&w=774&q=80 %&#125; &#123;% image https://images.unsplash.com/photo-1524797905120-92940d3a18d6?ixlib=rb-4.0.3&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&fit=crop&w=774&q=80 %&#125; &#123;% endswiper %&#125; ## 说说 &#123;% timeline hide:title,footer user:czsmall api:https://api.github.com/repos/czsmall/shuoshuo/issues?direction=asc&per_page=3 %&#125;&#123;% endtimeline %&#125; &#123;% endtabs %&#125; content: | # 支持 Markdown 格式 function show_runtime() { window.setTimeout(\"show_runtime()\", 1000); X = new Date(\"9/15/2023 00:00:00\"); Y = new Date(); T = (Y.getTime() - X.getTime()); M = 24 * 60 * 60 * 1000; a = T / M; A = Math.floor(a); b = (a - A) * 24; B = Math.floor(b); c = (b - B) * 60; C = Math.floor((b - B) * 60); D = Math.floor((c - C) * 60); runtime_span.innerHTML = \"⏱️本站已艰难运行 \" + A + \"天\" + B + \"小时\" + C + \"分\" + D + \"秒\" } show_runtime(); content: | # 支持 Markdown 格式 &lt;center&gt; &lt;div style=&quot;margin:0.2rem;&quot;&gt; &lt;a href=&quot;https://travellings.link&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://img.shields.io/badge/Travellings-开往--友链接力-86CAF2&quot; alt=&quot;Travellings&quot; /&gt;&lt;/a&gt; &lt;a href=&quot;https://www.foreverblog.cn/go.html&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://img.shields.io/badge/Wormhole-十年之约-D09968&quot; alt=&quot;穿梭虫洞--随机访问十年之约友链博客&quot; /&gt;&lt;/a&gt; &lt;/div&gt; &lt;br&gt; &lt;/br&gt; &lt;script type=&quot;text/javascript&quot;&gt; function show_runtime() &#123; window.setTimeout(&quot;show_runtime()&quot;, 1000); X = new Date(&quot;9/15/2023 00:00:00&quot;); Y = new Date(); T = (Y.getTime() - X.getTime()); M = 24 * 60 * 60 * 1000; a = T / M; A = Math.floor(a); b = (a - A) * 24; B = Math.floor(b); c = (b - B) * 60; C = Math.floor((b - B) * 60); D = Math.floor((c - C) * 60); runtime_span.innerHTML = &quot;⏱️本站已艰难运行 &quot; + A + &quot;天&quot; + B + &quot;小时&quot; + C + &quot;分&quot; + D + &quot;秒&quot; &#125; show_runtime(); &lt;/script&gt; &lt;span id=&quot;runtime_span&quot;&gt;&lt;/span&gt; &lt;/center&gt; &#123;% timeline hide:title,footer user:czsmall limit:7 api:https://api.github.com/repos/czsmall/shuoshuo/issues?direction=asc& %&#125;&#123;% endtimeline %&#125;? direction=asc&amp; 倒叙","tags":["未知"],"categories":["未知"]},{"title":"Hello World","path":"/2023/09/13/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment"},{"path":"/README.html","content":"opshxx.github.io"},{"path":"/about/index.html","content":"Hello.苦难不值得被歌颂，但希望永远值得被追捧友链留言 小站历程愿望清单说说2023 年 10 月 22 日基于GitHub Action实现动态友链订阅,看教程点点点2023 年 10 月 16 日本地git+server+nginx方式部署调试。2023 年 9 月 2 日 阿里云注册域名！ 愿望清单Unsplash PhotoThe Galactic Center is the rotational center of the Milky Way galaxy. Its central massive object is a supermassive black hole of about 4 million solar masses, which is called Sagittarius A*. Its mass is equal to four million suns. The center islocated 25,800 light years away from Earth. 说说"},{"path":"/bibi/index.html","content":"#?direction&#x3D;asc&amp;（放在issues后面可以实现倒叙）"},{"path":"/news/index.html","content":"20222023"},{"path":"/friends/index.html","content":"Hello. I’m Ant.对于可控的事情，要保持谨慎，对于不可控的事情，要保持乐观，人只能做自己能力范围内的事情，你要接受这个事实，并且以乐观的心去应对这一切； 友链留言 未雨筹谋GO-LINUX运维世界王先森XAOXUU酷小呵小白 友链动态 海内存知己，天涯若比邻未雨筹谋GO-LINUX运维世界王先森XAOXUU酷小呵小白 测试github同步 22号同步"},{"path":"/notes/index.html","content":"Hello. I’m Ant.对于可控的事情，要保持谨慎，对于不可控的事情，要保持乐观，人只能做自己能力范围内的事情，你要接受这个事实，并且以乐观的心去应对这一切； 官方文档技术支持 内容"},{"path":"/friends/rss/index.html","content":""},{"title":"标签o1","path":"/notes/n2/index.html","content":"sda faf af sf a"},{"title":"名称222","path":"/notes/n1/index.html","content":"sda faf af sf a"},{"title":"这是分页标题","path":"/wiki/docker/index - 副本.html","content":"Docker容器虚拟化学习目标： 掌握Docker基础知识，能够理解Docker镜像与容器的概念 完成Docker安装与启动 掌握Docker镜像与容器相关命令 掌握Tomcat Nginx 等软件的常用应用的安装 掌握docker迁移与备份相关命令 能够运用Dockerfile编写创建容器的脚本 能够搭建与使用docker私有仓库 第一章 Docker简介"},{"title":"这是分页标题","path":"/wiki/docker/index.html","content":"Docker容器虚拟化学习目标： 掌握Docker基础知识，能够理解Docker镜像与容器的概念 完成Docker安装与启动 掌握Docker镜像与容器相关命令 掌握Tomcat Nginx 等软件的常用应用的安装 掌握docker迁移与备份相关命令 能够运用Dockerfile编写创建容器的脚本 能够搭建与使用docker私有仓库 第一章 Docker简介1.1 什么是虚拟化虚拟化，是指通过虚拟化技术将一台计算机虚拟为多台逻辑计算机。在一台计算机上同时运行多个逻辑计算机，每个逻辑计算机可运行不同的操作系统，并且应用程序都可以在相互独立的空间内运行而互不影响，从而显著提高计算机的工作效率。 虚拟化技术种类很多，例如：软件虚拟化、硬件虚拟化、内存虚拟化、网络虚拟化(vip)、桌面虚拟化、服务虚拟化、虚拟机等等。 问题：为什么会有docker出现？ 一款产品从开发到上线，从操作系统，到运行环境，再到应用配置。作为开发+运维之间的协作我们需要关心很多东西，这也是很多互联网公司都不得不面对的问题，特别是各种版本的迭代之后，不同版本环境的兼容，对运维人员都是考验 , 这个时候 Docker 横空出世，是因为它对此给出了一个标准化的解决方案。 环境配置如此麻烦，换一台机器，就要重来一次，费力费时。很多人想到，能不能从根本上解决问题，软件可以带环境安装？也就是说，安装的时候，把原始环境一模一样地复制过来。开发人员利用 Docker 可以消除协作编码时“在我的机器上可正常工作”的问题。 之前，可以发现，每发布一个程序，都要走一遍以上的流程： 1.2 什么是DockerDocker 是一个开源的应用容器引擎，基于 Go 语言开发。Docker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口（类似 iPhone 的 app）,更重要的是容器性能开销极低。 Docker的主要目标是“Build，Ship and Run Any App,Anywhere”，也就是通过对应用组件的封装、分发、部署、运行等生命周期的管理，使用户的APP（可以是一个WEB应用或数据库应用等等）及其运行环境能够做到“一次封装，到处运行”。 总之一句话：只需要一次配置好环境，换到别的机子上就可以一键部署好，大大简化了操作 。 为什么选择Docker? Docker的镜像提供了除内核外完整的运行时环境，确保了应用运行环境一致性，从而不会再出现“这段代码在我机器上没问题啊”这类问题；——一致的运行环境 可以做到秒级、甚至毫秒级的启动时间。大大的节约了开发、测试、部署的时间。——更快速的启动时间 避免公用的服务器，资源会容易受到其他用户的影响。——隔离性 善于处理集中爆发的服务器使用压力；——弹性伸缩，快速扩展 可以很轻易的将在一个平台上运行的应用，迁移到另一个平台上，而不用担心运行环境的变化导致应用无法正常运行的情况。——迁移方便 使用Docker可以通过定制应用镜像来实现持续集成、持续交付、部署。——持续交付和部署 Docker应用场景 ① Web 应用的自动化打包和发布 ② 自动化测试和持续集成、发布 ③ 在服务型环境中部署和调整数据库或其他的后台应用 使用Docker可以实现开发人员的开发环境、测试人员的测试环境、运维人员的生产环境的一致性。 Docker借鉴了标准集装箱的概念。标准集装箱将货物运往世界各地，Docker将这个模型运用到自己的设计中，唯一不同的是：集装箱运输货物，而Docker运输软件。 1.3 容器与虚拟机比较下面的图片比较了 Docker 和传统虚拟化方式的不同之处，可见容器是在操作系统层面上实现虚拟化，直接复用本地主机的操作系统，而传统方式则是在硬件层面实现。 传统虚拟机 传统虚拟机技术基于安装在主操作系统上的虚拟机管理系统（如：VirtualBox和VMWare等），创建虚拟机（虚拟出各种硬件），在虚拟机上安装从操作系统，在从操作系统中安装部署各种应用。 Docker Docker容器是在操作系统层面上实现虚拟化，直接复用本地主机的操作系统，而传统虚拟机则是在硬件层面实现虚拟化。与传统的虚拟机相比，Docker优势体现为启动速度快、占用体积小。 使用上的区别 简单来说： 容器和虚拟机具有相似的资源隔离和分配优势，但功能有所不同，因为容器虚拟化的是操作系统，而不是硬件，因此容器更容易移植，效率也更高。 1.4 Docker 组件1.4.1 Docker组成部分Docker是一个客户端-服务器（C&#x2F;S）架构程序。Docker客户端只需要向Docker服务器或者守护进程发出请求，服务器或者守护进程将完成所有工作并返回结果。Docker提供了一个命令行工具Docker以及一整套RESTful API。你可以在同一台宿主机上运行Docker守护进程和客户端，也可以从本地的Docker客户端连接到运行在另一台宿主机上的远程Docker守护进程。 1.4.2 Docker镜像与容器镜像：类似虚拟机镜像 , 是一个特殊的文件系统 操作系统分为内核和用户空间。对于Linux而言，内核启动后，会挂载root文件系统为其提供用户空间支持。而Docker镜像（Image），就相当于是一个root文件系统。 Docker镜像是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。 镜像不包含任何动态数据，其内容在构建之后也不会被改变。 容器：类似linux系统环境，运行和隔离应用。是镜像运行时的实体 镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中的类和实例一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等 。 仓库：集中存放镜像文件的地方。 镜像构建完成后，可以很容易的在当前宿主上运行，但是， 如果需要在其它服务器上使用这个镜像，我们就需要一个集中存储、分发镜像的地方，比如后面我们要学的，Docker Registry就是这样的服务。 1.4.3 Registry（注册中心）Docker用Registry来保存用户构建的镜像。Registry分为公共和私有两种。Docker公司运营公共的Registry叫做Docker Hub。用户可以在Docker Hub注册账号，分享并保存自己的镜像（说明：在Docker Hub下载镜像巨慢，可以自己构建私有的Registry）。 https://hub.docker.com/ 第二章 Docker安装与启动2.1 安装Docker-CentOS7Docker官方建议在Ubuntu中安装，因为Docker是基于Ubuntu发布的，而且一般Docker出现的问题Ubuntu是最先更新或者打补丁的。在很多版本的CentOS中是不支持更新最新的一些补丁包的。​ 由于我们学习的环境都使用的是CentOS，因此这里我们将Docker安装到CentOS上。 注意：这里建议安装在CentOS7.x以上的版本，在CentOS6.x的版本中，安装前需要安装其他很多的环境，而且Docker很多补丁不支持更新。 官网中文安装参考手册 https://docs.docker.com/install/linux/docker-ce/centos/ 确定你是CentOS7及以上版本 cat &#x2F;etc&#x2F;redhat-release yum安装gcc相关 CentOS7能上外网 检查gcc和g++是否安装好，如果没有安装好，则需要安装。 安装gcc和g++ yum -y install gcc yum -y install gcc-c++ 安装需要的软件包 yum install -y yum-utils device-mapper-persistent-data lvm2 设置镜像仓库 大坑(千万不要试，网速慢，超时，安装不上) yum-config-manager –add-repo （centos快速添加yum源）https://download.docker.com/linux/centos/docker-ce.repo 报错：官网太慢，一定超时。 [Errno 14] curl#35 - TCP connection reset by peer [Errno 12] curl#35 - Timeout 推荐：阿里云服务器 yum-config-manager –add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo 更新yum软件包索引 yum makecache fast 安装DOCKER CE（社区版）（DOCKER EE企业版收费） yum -y install docker-ce 启动docker 手动启动：systemctl start docker 自动启动：systemctl enable docker 测试 检查版本：docker version 下载并运行HelloWorld：docker run hello-world 如果下载不下来，可以配置镜像加速器 输出这段提示以后，hello world就会停止运行，容器自动终止。 run干了什么 配置镜像加速CentOS7版本 mkdir -p &#x2F;etc&#x2F;docker vim &#x2F;etc&#x2F;docker&#x2F;daemon.json #网易云 { “registry-mirrors”: [“http://hub-mirror.c.163.com“] } #阿里云(推荐) { “registry-mirrors”: [“https://8y2y8njn.mirror.aliyuncs.com“] } #ustc #是老牌的linux镜像服务提供者了，还在遥远的ubuntu 5.04版本的时候就在用。ustc的docker镜像加速器速度很快。 #ustc docker mirror的优势之一就是不需要注册，是真正的公共服务。 #https://lug.ustc.edu.cn/wiki/mirrors/help/docker 在该文件中输入如下内容： { “registry-mirrors”: [“https://docker.mirrors.ustc.edu.cn“] } systemctl daemon-reload systemctl restart docker 卸载 systemctl stop docker yum -y remove docker-ce rm -rf &#x2F;var&#x2F;lib&#x2F;docker 卸载旧版本 2019.11英文官网版本 最新的英文版：https://docs.docker.com/install/linux/docker-ce/centos/\\#uninstall-old-versions yum remove docker \\ docker-client \\ docker-client-latest \\ docker-common \\ docker-latest \\ docker-latest-logrotate \\ docker-logrotate \\ docker-engine 2.2 Docker的启动与停止2.2.1 命令 启动docker： systemctl start docker 停止docker： systemctl stop docker 重启docker： systemctl restart docker 查看docker状态： systemctl status docker 开机启动： systemctl enable docker 查看docker概要信息： docker info 查看docker帮助文档： docker –help 2.2.2 帮助手册：docker –help 2.2.3 指令介绍 cp 本地文件系统(OS操作系统|宿主机)和容器之间进行文件或者文件夹拷贝 exec 登录一个容器，使用命令行操作正在运行的容器。 images 镜像的集合查询。 ps 容器列表 pull 下载镜像 restart 重启一个或多个容器 rm 删除一个或多个容器 rmi 删除一个或多个镜像 run 创建一个容器，并运行起来 save 导出镜像到一个文件(tar)中 search 搜索镜像（从Docker Hub） start 启动一个或多个已经停止的容器 stop 停止一个或多个正在运行的容器 第三章 常用命令镜像：Docker镜像是由文件系统叠加而成（是一种文件的存储形式）；是docker中的核心概念，可以认为镜像就是对某些运行环境或者软件打的包，用户可以从docker仓库中下载基础镜像到本地，比如，开发人员可以从docker仓库拉取（下载）一个只包含centos7系统的基础镜像，然后在这个镜像中安装jdk、mysql、Tomcat和自己开发的应用，最后将这些环境打成一个新的镜像。开发人员将这个新的镜像提交给测试人员进行测试，测试人员只需要在测试环境下运行这个镜像就可以了，这样就可以保证开发人员的环境和测试人员的环境完全一致。 3.1 镜像相关命令3.1.1 查看镜像查看镜像可以使用如下命令：docker images REPOSITORY：镜像名称 TAG：镜像标签（版本） IMAGE ID：镜像ID CREATED：镜像的创建日期（不是获取该镜像的日期） SIZE：镜像大小 这些镜像都是存储在Docker的 &#x2F;var&#x2F;lib&#x2F;docker 目录下 3.1.2 搜索镜像从网络中查找需要的镜像：docker search 镜像名称 例如 下载一个 nginx 镜像 NAME：仓库名称 DESCRIPTION：镜像描述 STARS：用户评价，反应一个镜像的受欢迎程度 OFFICIAL：是否官方 AUTOMATED：自动构建，表示该镜像由Docker Hub自动构建流程创建 3.1.3 拉取镜像拉取镜像就是从Docker仓库下载镜像到本地，镜像名称格式为 【名称:版本号】，如果版本号不指定则是最新的版本 命令：docker pull 镜像名称下载一个 nginx 的镜像 , 需要注意：如果下载的时候，不指定版本，会下载最新版本 刚刚下载的镜像通过 docker images 就可以查看 3.1.4 删除镜像可以按照镜像id删除镜像，命令如下：docker rmi 镜像ID 删除单个镜像(-f 强制删除)：docker rmi -f 镜像ID 删除多个镜像：docker rmi -f 镜像名1:TAG 镜像名2:TAG 删除所有镜像：docker rmi -f $(docker images -qa) 3.15 从Docker Hub拉取Docker镜像首页，包括官方镜像和其它公开镜像。Docker Hub上最受欢迎的10大镜像（通过Docker registry API获取不了镜像被pull的个数，只能通过镜像的stars数量来衡量镜像的流行度。毫无疑问，拥有最高stars数量的库都是官方库）。 https://hub.docker.com/search?image_filter=official&amp;type=image 国情的原因，国内下载 Docker HUB 官方的相关镜像比较慢，可以使用国内（docker.io）的一些镜像加速器，镜像保持和官方一致，关键是速度快，推荐使用。 3.2 容器相关命令容器也是docker中的核心概念，镜像是创建容器的软件 , 容器是由镜像运行产生的运行实例。镜像和容器的关系，就如同Java语言中类和对象的关系。 如果需要通俗的描述容器的话，我觉得容器就是一个存放东西的地方，就像书包可以装各种文具、衣柜可以放各种衣服、鞋架可以放各种鞋子一样。我们现在所说的容器存放的东西可能更偏向于应用。比如网站、程序甚至是系统环境。 3.2.1 查看容器 查看正在运行的容器： docker ps 查看所有容器： docker ps –a 查看最后一次运行的容器： docker ps –l 查看停止的容器： docker ps -f status&#x3D;exited 3.2.2 创建与启动容器① 什么是宿主机？ 就是主机，这个概念是相对于子机而言的，比如你安装有虚拟机的话，那么相对于虚拟机而言，你正在使用的计算机就是宿主机，虚拟机是安装在主机上的，必须在主机上才能运行，主机就是一个“宿主”。 ② 创建容器常用的参数说明： 创建容器命令：docker run -i：表示运行容器 -t：表示容器启动后会进入其命令行。加入这两个参数后，容器创建就能登录进去。即分配一个伪终端。 –name :为创建的容器命名。 -v：表示目录映射关系（前者是宿主机目录，后者是映射到宿主机上的目录），可以使用多个－v做多个目录或文件映射。注意：最好做目录映射，在宿主机上做修改，然后共享到容器上。 -d：在run后面加上-d参数,则会创建一个守护式容器在后台运行（这样创建容器后不会自动登录容器，如果只加-i -t两个参数，创建后就会自动进去容器）。 -p：表示端口映射，前者是宿主机端口，后者是容器内的映射端口。可以使用多个-p做多个端口映射 （1）交互式方式创建容器 以交互式方式创建并启动容器，启动完成后，直接进入当前容器。使用exit命令退出容器。需要注意的是以此种方式启动容器，如果退出容器，则容器会进入停止状态。可以理解成交互式容器 是前台容器。 1234567docker run -it --name=容器名称 镜像名称:标签 /bin/bash# 比如：docker run -it --name=mycentos centos:7 /bin/bash# docker run:表示创建容器# -it：表示运行容器并进入它的命令行# --name=mycentos：给当前的容器命名# centos:7：使用该镜像创建# /bin/bash：放在镜像名后的是命令，这里我们希望有个交互式 Shell，因此用的是 /bin/bash 创建好容器，并且已经进入到容器内部了，可以直接观察前面中括号里面的内容发现，跟创建容器之前不一样了， 并且 通过 dir 命令，会发现，其实容器内部也是一个 centos , 我们可以把每个容器都看成一个小电脑或者服务器 重新开一个新的会话，查看刚刚创建的容器是否已经有了。 查看正在运行的容器：docker ps 退出当前容器：exit 退出之后，容器也退出了，没有删除 (2) 创建后台容器 docker run -id –name&#x3D;mycentos2 centos:7 查看 docker 容器已经运行 (3) 守护式方式创建容器： 创建一个守护式容器；如果对于一个需要长期运行的容器来说，我们可以创建一个守护式容器。 命令如下（容器名称不能重复）：守护容器可以理解成在后台运行的容器 12345# 守护式容器和交互式容器的创建方式区别：# ① -it 换成 -di# ② 去掉后面的 /bin/bashdocker run -di --name=容器名称 镜像名称:标签# 比如：docker run -di --name=mycentos10 centos:7 通过 docker ps 查看容器已经是运行状态 进入守护式容器方式： 12docker exec -it 容器名称 (或者容器ID) /bin/bash# 比如 docker exec -it mycentos10 /bin/bash 已经进入到容器内部了，如果现在退出exit，然后查看容器docker ps是否还在后台运行（仍在运行） 3.2.3 停止与启动容器 先通过 docker ps 查看正在运行的容器 停止容器： docker stop 容器名称（或者容器ID） 例如： docker stop mycentos2 创建完容器之后，停止容器 查看容器是否已经停止 启动容器： docker start 容器名称（或者容器ID） 例如： docker start mycentos2 （以交互式运行的容器，只是第一次exit退出的时候会关闭容器，当用start启动的时候，就相当于后台启动了，exec进去之后再exit退出不会关闭容器） 查看容器是否已经启动 3.2.4 文件拷贝我们需要在容器内安装一个软件，软件首先需要有安装包，我们就需要把安装包拷贝到容器内。我们通常的操作是先把文件上传到宿主机，然后我们在将文件从宿主机拷贝到容器内的某个目录下面进行安装。 将linux宿主机中的文件拷贝到容器内可以使用命令： 如果我们需要将文件拷贝到容器内可以使用cp命令 docker cp 需要拷贝的文件或目录 容器名称:容器目录 例如： docker cp anaconda-ks.cfg mycentos2:&#x2F;usr&#x2F;local&#x2F; 拷贝一个文件到 mycentos2 的 &#x2F;urs&#x2F;local&#x2F; 文件下面 ，拷贝完成之后，删除文件，然后在mycentos2拷贝过来 登录容器查看拷贝之后的结果 docker exec -it mycentos2 &#x2F;bin&#x2F;bash docker exec：表示登陆正在运行的容器 -it：进入命令行 mycentos2：进入到该容器 也可以将文件从容器内拷贝出来 docker cp 容器名称:容器目录 需要拷贝的文件或目录 例如：docker cp mycentos2:&#x2F;usr&#x2F;local&#x2F;anaconda-ks.cfg .&#x2F; 我们先通过 exit 退出容器，然后在把文件从容器拷贝到当前目录 3.2.5 目录挂载我们可以在创建容器的时候，将宿主机的目录与容器内的目录进行映射，这样我们就可以通过修改宿主机某个目录的文件从而去影响容器。 创建容器 添加-v参数 后边为 宿主机目录:容器目录，例如： # 创建并启动容器mycentos3,并挂载linux中的&#x2F;usr&#x2F;local&#x2F;myhtml目录到容器的&#x2F;usr&#x2F;local&#x2F;myhtml；也就是在linux中的&#x2F;usr&#x2F;local&#x2F;myhtml中操作相当于对容器相应目录操作 docker run -di –name&#x3D;容器的名字 -v &#x2F;usr&#x2F;local&#x2F;myhtml:&#x2F;usr&#x2F;local&#x2F;myhtml centos:7 比如：docker run -di –name&#x3D;mycentos3 -v &#x2F;usr&#x2F;local&#x2F;myhtml:&#x2F;usr&#x2F;local&#x2F;myhtml centos:7 通过 docker ps 查看正在运行的容器，在创建容器并且进行目录挂载，然后在通过 docker ps 查看刚刚创建的容器是否已经创建 进入到 myhtml 目录 ，通过dir查看是否有文件，通过vi test2 ，创建一个文件，进入test2文件，随便输入一些数据 进入目录随便输入一些东西 ， 退出保存 登录容器，查看刚刚输入的内容 hsg sdg d"}]